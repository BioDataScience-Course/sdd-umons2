<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>2.4 RMSE &amp; critère d’Akaike | Science des données biologiques 2</title>
  <meta name="description" content="Tutoriel interactif pour la science des données avec R &amp; SciViews-R, partie 2.">
  <meta name="generator" content="bookdown  and GitBook 2.6.7">

  <meta property="og:title" content="2.4 RMSE &amp; critère d’Akaike | Science des données biologiques 2" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="https://biodatascience-course.sciviews.org/sdd-umons2/" />
  <meta property="og:image" content="https://biodatascience-course.sciviews.org/sdd-umons2/images/front-cover.png" />
  <meta property="og:description" content="Tutoriel interactif pour la science des données avec R &amp; SciViews-R, partie 2." />
  <meta name="github-repo" content="biodatascience-course/sdd-umons2" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="2.4 RMSE &amp; critère d’Akaike | Science des données biologiques 2" />
  
  <meta name="twitter:description" content="Tutoriel interactif pour la science des données avec R &amp; SciViews-R, partie 2." />
  <meta name="twitter:image" content="https://biodatascience-course.sciviews.org/sdd-umons2/images/front-cover.png" />

<meta name="author" content="Philippe Grosjean &amp; Guyliann Engels">


<meta name="date" content="2019-11-07">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="regression-lineaire-polynomiale.html">
<link rel="next" href="reg-non-lin.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<script src="libs/htmlwidgets-1.3/htmlwidgets.js"></script>
<script src="libs/plotly-binding-4.8.0/plotly.js"></script>
<script src="libs/typedarray-0.1/typedarray.min.js"></script>
<link href="libs/crosstalk-1.0.0/css/crosstalk.css" rel="stylesheet" />
<script src="libs/crosstalk-1.0.0/js/crosstalk.min.js"></script>
<link href="libs/plotly-htmlwidgets-css-1.39.2/plotly-htmlwidgets.css" rel="stylesheet" />
<script src="libs/plotly-main-1.39.2/plotly-latest.min.js"></script>
<link href="libs/rglwidgetClass-2/rgl.css" rel="stylesheet" />
<script src="libs/rglwidgetClass-2/rglClass.src.js"></script>
<script src="libs/CanvasMatrix4-2016/CanvasMatrix.src.js"></script>
<script src="libs/rglWebGL-binding-0.100.19/rglWebGL.js"></script>


<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    background-color: #ffffff;
    color: #a0a0a0;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #a0a0a0;  padding-left: 4px; }
div.sourceCode
  { color: #1f1c1b; background-color: #ffffff; }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span. { color: #1f1c1b; } /* Normal */
code span.al { color: #bf0303; background-color: #f7e6e6; font-weight: bold; } /* Alert */
code span.an { color: #ca60ca; } /* Annotation */
code span.at { color: #0057ae; } /* Attribute */
code span.bn { color: #b08000; } /* BaseN */
code span.bu { color: #644a9b; font-weight: bold; } /* BuiltIn */
code span.cf { color: #1f1c1b; font-weight: bold; } /* ControlFlow */
code span.ch { color: #924c9d; } /* Char */
code span.cn { color: #aa5500; } /* Constant */
code span.co { color: #898887; } /* Comment */
code span.cv { color: #0095ff; } /* CommentVar */
code span.do { color: #607880; } /* Documentation */
code span.dt { color: #0057ae; } /* DataType */
code span.dv { color: #b08000; } /* DecVal */
code span.er { color: #bf0303; text-decoration: underline; } /* Error */
code span.ex { color: #0095ff; font-weight: bold; } /* Extension */
code span.fl { color: #b08000; } /* Float */
code span.fu { color: #644a9b; } /* Function */
code span.im { color: #ff5500; } /* Import */
code span.in { color: #b08000; } /* Information */
code span.kw { color: #1f1c1b; font-weight: bold; } /* Keyword */
code span.op { color: #1f1c1b; } /* Operator */
code span.ot { color: #006e28; } /* Other */
code span.pp { color: #006e28; } /* Preprocessor */
code span.re { color: #0057ae; background-color: #e0e9f8; } /* RegionMarker */
code span.sc { color: #3daee9; } /* SpecialChar */
code span.ss { color: #ff5500; } /* SpecialString */
code span.st { color: #bf0303; } /* String */
code span.va { color: #0057ae; } /* Variable */
code span.vs { color: #bf0303; } /* VerbatimString */
code span.wa { color: #bf0303; } /* Warning */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Science des données biologiques 2</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Préambule</a><ul>
<li class="chapter" data-level="" data-path="vue-generale-des-cours.html"><a href="vue-generale-des-cours.html"><i class="fa fa-check"></i>Vue générale des cours</a></li>
<li class="chapter" data-level="" data-path="materiel-pedagogique.html"><a href="materiel-pedagogique.html"><i class="fa fa-check"></i>Matériel pédagogique</a></li>
</ul></li>
<li class="part"><span><b>I Cours II: analyse et modélisation</b></span></li>
<li class="chapter" data-level="1" data-path="lm.html"><a href="lm.html"><i class="fa fa-check"></i><b>1</b> Régression linéaire I</a><ul>
<li class="chapter" data-level="1.1" data-path="modele.html"><a href="modele.html"><i class="fa fa-check"></i><b>1.1</b> Modèle</a><ul>
<li class="chapter" data-level="1.1.1" data-path="modele.html"><a href="modele.html#pourquoi-modeliser"><i class="fa fa-check"></i><b>1.1.1</b> Pourquoi modéliser ?</a></li>
<li class="chapter" data-level="1.1.2" data-path="modele.html"><a href="modele.html#quand-modeliser"><i class="fa fa-check"></i><b>1.1.2</b> Quand modéliser ?</a></li>
<li class="chapter" data-level="1.1.3" data-path="modele.html"><a href="modele.html#entrainement-et-confirmation"><i class="fa fa-check"></i><b>1.1.3</b> Entraînement et confirmation</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="regression-lineaire-simple.html"><a href="regression-lineaire-simple.html"><i class="fa fa-check"></i><b>1.2</b> Régression linéaire simple</a><ul>
<li class="chapter" data-level="1.2.1" data-path="regression-lineaire-simple.html"><a href="regression-lineaire-simple.html#quantifier-lajustement-dun-modele"><i class="fa fa-check"></i><b>1.2.1</b> Quantifier l’ajustement d’un modèle</a></li>
<li class="chapter" data-level="1.2.2" data-path="regression-lineaire-simple.html"><a href="regression-lineaire-simple.html#trouver-la-meilleure-droite"><i class="fa fa-check"></i><b>1.2.2</b> Trouver la meilleure droite</a></li>
<li class="chapter" data-level="1.2.3" data-path="regression-lineaire-simple.html"><a href="regression-lineaire-simple.html#la-fonction-lm"><i class="fa fa-check"></i><b>1.2.3</b> La fonction <code>lm()</code></a></li>
<li class="chapter" data-level="1.2.4" data-path="regression-lineaire-simple.html"><a href="regression-lineaire-simple.html#resume-avec-summary"><i class="fa fa-check"></i><b>1.2.4</b> Résumé avec <code>summary()</code></a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="outils-de-diagnostic.html"><a href="outils-de-diagnostic.html"><i class="fa fa-check"></i><b>1.3</b> Outils de diagnostic</a><ul>
<li class="chapter" data-level="1.3.1" data-path="outils-de-diagnostic.html"><a href="outils-de-diagnostic.html#analyse-des-residus"><i class="fa fa-check"></i><b>1.3.1</b> Analyse des résidus</a></li>
<li class="chapter" data-level="1.3.2" data-path="outils-de-diagnostic.html"><a href="outils-de-diagnostic.html#enveloppe-de-confiance"><i class="fa fa-check"></i><b>1.3.2</b> Enveloppe de confiance</a></li>
<li class="chapter" data-level="1.3.3" data-path="outils-de-diagnostic.html"><a href="outils-de-diagnostic.html#extraire-les-donnees-dun-modele"><i class="fa fa-check"></i><b>1.3.3</b> Extraire les données d’un modèle</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="lm2.html"><a href="lm2.html"><i class="fa fa-check"></i><b>2</b> Régression linéaire II</a><ul>
<li class="chapter" data-level="2.1" data-path="outils-de-diagnostic-suite.html"><a href="outils-de-diagnostic-suite.html"><i class="fa fa-check"></i><b>2.1</b> Outils de diagnostic (suite)</a><ul>
<li class="chapter" data-level="2.1.1" data-path="outils-de-diagnostic-suite.html"><a href="outils-de-diagnostic-suite.html#resume-avec-summarysuite"><i class="fa fa-check"></i><b>2.1.1</b> Résumé avec <code>summary()</code>(suite)</a></li>
<li class="chapter" data-level="2.1.2" data-path="outils-de-diagnostic-suite.html"><a href="outils-de-diagnostic-suite.html#comparaison-de-regressions"><i class="fa fa-check"></i><b>2.1.2</b> Comparaison de régressions</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="regression-lineaire-multiple.html"><a href="regression-lineaire-multiple.html"><i class="fa fa-check"></i><b>2.2</b> Régression linéaire multiple</a></li>
<li class="chapter" data-level="2.3" data-path="regression-lineaire-polynomiale.html"><a href="regression-lineaire-polynomiale.html"><i class="fa fa-check"></i><b>2.3</b> Régression linéaire polynomiale</a></li>
<li class="chapter" data-level="2.4" data-path="rmse-critere-dakaike.html"><a href="rmse-critere-dakaike.html"><i class="fa fa-check"></i><b>2.4</b> RMSE &amp; critère d’Akaike</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="reg-non-lin.html"><a href="reg-non-lin.html"><i class="fa fa-check"></i><b>3</b> Régression non linéaire</a></li>
<li class="chapter" data-level="4" data-path="hierarchique.html"><a href="hierarchique.html"><i class="fa fa-check"></i><b>4</b> Classification hiérarchique</a></li>
<li class="chapter" data-level="5" data-path="k-moyenne-som.html"><a href="k-moyenne-som.html"><i class="fa fa-check"></i><b>5</b> K-moyenne &amp; SOM</a><ul>
<li class="chapter" data-level="5.1" data-path="k-moyennes.html"><a href="k-moyennes.html"><i class="fa fa-check"></i><b>5.1</b> K-moyennes</a></li>
<li class="chapter" data-level="5.2" data-path="cartes-auto-adaptatives.html"><a href="cartes-auto-adaptatives.html"><i class="fa fa-check"></i><b>5.2</b> Cartes auto adaptatives</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="acp-afc.html"><a href="acp-afc.html"><i class="fa fa-check"></i><b>6</b> ACP &amp; AFC</a><ul>
<li class="chapter" data-level="6.1" data-path="analyse-en-composantes-principales.html"><a href="analyse-en-composantes-principales.html"><i class="fa fa-check"></i><b>6.1</b> Analyse en composantes principales</a></li>
<li class="chapter" data-level="6.2" data-path="analyse-factorielle-des-correspondances.html"><a href="analyse-factorielle-des-correspondances.html"><i class="fa fa-check"></i><b>6.2</b> Analyse factorielle des correspondances</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="afm.html"><a href="afm.html"><i class="fa fa-check"></i><b>7</b> AFM</a><ul>
<li class="chapter" data-level="7.1" data-path="analyse-factorielle-multiple-afm.html"><a href="analyse-factorielle-multiple-afm.html"><i class="fa fa-check"></i><b>7.1</b> Analyse factorielle multiple (AFM)</a></li>
</ul></li>
<li class="appendix"><span><b>Appendices</b></span></li>
<li class="chapter" data-level="A" data-path="svbox.html"><a href="svbox.html"><i class="fa fa-check"></i><b>A</b> Installation de la SciViews Box</a><ul>
<li class="chapter" data-level="A.1" data-path="migration-des-projets.html"><a href="migration-des-projets.html"><i class="fa fa-check"></i><b>A.1</b> Migration des projets</a></li>
<li class="chapter" data-level="A.2" data-path="configuration-git-et-github.html"><a href="configuration-git-et-github.html"><i class="fa fa-check"></i><b>A.2</b> Configuration Git et Github</a><ul>
<li class="chapter" data-level="A.2.1" data-path="configuration-git-et-github.html"><a href="configuration-git-et-github.html#compte-github-dans-rstudio"><i class="fa fa-check"></i><b>A.2.1</b> Compte Github dans RStudio</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i>Références</a></li>
<li class="divider"></li>
<li><a href="http://biodatascience-course.sciviews.org">Site Web du cours</a></li>
<li><a href="https://github.com/BioDataScience-Course">Site Github du cours</a></li>
<br/>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Publié avec bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Science des données biologiques 2</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="rmse-critere-dakaike" class="section level2">
<h2><span class="header-section-number">2.4</span> RMSE &amp; critère d’Akaike</h2>
<p>Le <em>R<sup>2</sup></em> (ajusté) n’est pas la seule mesure d’ajustement d’un modèle. Il existe d’autres indicateurs. Par exemple, l’<strong>erreur quadratique moyenne</strong>, (root mean square error, ou RMSE en anglais) est la racine carrée de la moyenne des résidus au carré. Elle représente en quelque sorte la distance “typique” des résidus. Comme cette distance est exprimée dans les mêmes unités que l’axe <em>y</em>, cette mesure est particulièrement parlante. Nous pouvons l’obtenir par exemple comme ceci :</p>
<pre class="sourceCode r"><code class="sourceCode r">modelr<span class="op">::</span><span class="kw">rmse</span>(lm., trees)</code></pre>
<pre><code># [1] 0.1166409</code></pre>
<p>Cela signifie que l’on peut s’attendre à ce que, en moyenne, les valeurs prédites de volume de bois s’écartent (dans un sens ou dans l’autre) de 0,117 m<sup>3</sup> de la valeur effectivement observée. Evidemment, plus un modèle est bon, plus le RMSE est <strong>faible</strong>, contrairement au <em>R<sup>2</sup></em> qui lui doit être <strong>élevé</strong>.</p>
<p>Si le <em>R<sup>2</sup></em> comme le RMSE sont utiles pour quantifier la qualité d’ajustement d’<em>une</em> régression, ces mesures sont peu adaptées pour la comparaison de modèles entre eux. En effet, nous avons vu que plus le modèle est complexe, mieux il s’ajuste dans les données. Le <em>R<sup>2</sup> ajusté</em> tente de remédier partiellement à ce problème, mais cette métrique reste peu fiable pour comparer des modèles très différents. Le <strong>critère d’Akaike</strong>, du nom du statisticien japonais qui l’a conçu, est une métrique plus adaptée à de telles comparaisons. Elle se base au départ sur encore une autre mesure de la qualité d’ajustement d’un modèle : la <strong>log-vraisemblance</strong>. Les explications relatives à cette mesure sont obligatoirement complexes d’un point de vue mathématique et nous vous proposons ici d’en retenir la définition sur un plan purement conceptuel. Un <strong>estimateur de maximum de vraisemblance</strong> est une mesure qui permet d’inférer le meilleur ajustement possible d’une loi de probabilité par rapport à des données. Dans le cas de la régression par les moindres carrés, la distribution de probabilité à ajuster est celle des résidus (pour rappel, il s’agit d’une distribution Normale de moyenne nulle et d’écart type constant <span class="math inline">\(\sigma\)</span>). La <strong>log-vraisemblance</strong>, pour des raisons purement techniques est souvent préféré au maximum de vraissemblance. Il s’agit simplement du logarithme de sa valeur.</p>
<p>Donc, plus la log-vraisemblance est grande, mieux les données sont compatibles avec le modèle probabiliste considéré. <strong>Pour un même jeu de données</strong>, ces valeurs sont comparables entre elles… même pour des modèles très différents. Mais cela ne règle pas la question de la complexité du modèle. C’est ici qu’Akaike entre en piste. Il propose le critère suivant :</p>
<p><span class="math display">\[
\textrm{AIC} = -2 . \textrm{log-vraisemblance} + 2 . \textrm{nbrpar}
\]</span></p>
<ul>
<li>où <strong>nbrpar</strong> est le nombre de paramètres à estimer dans le modèle. Donc ici, nous prenons comme point de départ moins deux fois la log-vraisemblance, une valeur <em>a priori</em> à <strong>minimiser</strong>, mais nous lui ajoutons le second terme de <strong>pénalisation</strong> en fonction de la complexité du modèle valant 2 fois le nombre de paramètres du modèle. Notons d’ailleurs que le terme multiplicateur 2 ici est modifiable. Si nous voulons un modèle le moins complexe possible, nous pourrions très bien multiplier par 3 ou 4 pour pénaliser encore plus. Et si nous voulons être moins restrictifs, nous pouvons aussi diminuer ce facteur multiplicatif. Dans la pratique, le facteur 2 est quand même très majoritairement adapté par les praticiens, mais la possibilité de changer l’impact de complexité du modèle est inclue dans le calcul <em>de facto</em>.</li>
</ul>
<p>Dès lors que ce critère peut être calculé (et R le fait pour pratiquement tous les modèles qu’il propose), une comparaison est possible avec pour objectif de sélectionner le, ou un des modèles qui a l’AIC <strong>la plus faible</strong>. N’oubliez toutefois pas de comparer <em>visuellement</em> les différents modèles ajustés et d’interpréter les graphiques d’analyse des résidus respectifs en plus des valeurs d’AIC. <strong>C’est l’ensemble de ces outils qui vous orientent vers le meilleur modèle, pas l’AIC seul !</strong></p>
<p>Calculons maintenant les critères d’Akaike pour nos 6 modèles <code>lm.</code> à <code>lm5</code>…</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">AIC</span>(lm.) <span class="co"># Linéaire diamètre</span></code></pre>
<pre><code># [1] -39.24246</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">AIC</span>(lm2) <span class="co"># Multiple diamètre et hauteur</span></code></pre>
<pre><code># [1] -43.82811</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">AIC</span>(lm3) <span class="co"># Polynomial diamètre</span></code></pre>
<pre><code># [1] -53.50964</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">AIC</span>(lm4) <span class="co"># Diamètre^2</span></code></pre>
<pre><code># [1] -50.15027</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">AIC</span>(lm5) <span class="co"># Multiple et polynomial</span></code></pre>
<pre><code># [1] -67.4391</code></pre>
<p>D’après ce critère, le modèle linéaire est le moins bon, et le dernier modèle le plus complexe serait le meilleur. Notez toutefois que la différence est relativement minime (en regard du gain total) entre le modèle polynomial complet <code>lm3</code> et la version simplifié au seul terme diamètre<sup>2</sup> en <code>lm4</code>, ce qui permet de penser que cette simplification est justifiée.</p>
<p>Dans l’hypothèse où nous déciderions de conserver le modèle <code>lm5</code>, en voici l’analyse des résidus qui est bonne dans l’ensemble :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co">#plot(lm5, which = 1)</span>
lm5 <span class="op">%&gt;.%</span>
<span class="st">  </span><span class="kw">chart</span>(broom<span class="op">::</span><span class="kw">augment</span>(.), .resid <span class="op">~</span><span class="st"> </span>.fitted) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_hline</span>(<span class="dt">yintercept =</span> <span class="dv">0</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">se =</span> <span class="ot">FALSE</span>, <span class="dt">method =</span> <span class="st">&quot;loess&quot;</span>, <span class="dt">formula =</span> y <span class="op">~</span><span class="st"> </span>x) <span class="op">+</span>
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">&quot;Fitted values&quot;</span>, <span class="dt">y =</span> <span class="st">&quot;Residuals&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Residuals vs Fitted&quot;</span>) </code></pre>
<p><img src="02-reg-lineaire-2_files/figure-html/unnamed-chunk-23-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co">#plot(lm5, which = 2)</span>
lm5 <span class="op">%&gt;.%</span>
<span class="st">  </span><span class="kw">chart</span>(broom<span class="op">::</span><span class="kw">augment</span>(.), <span class="kw">aes</span>(<span class="dt">sample =</span> .std.resid)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_qq</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_qq_line</span>(<span class="dt">colour =</span> <span class="st">&quot;darkgray&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">&quot;Theoretical quantiles&quot;</span>, <span class="dt">y =</span> <span class="st">&quot;Standardized residuals&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Normal Q-Q&quot;</span>) </code></pre>
<p><img src="02-reg-lineaire-2_files/figure-html/unnamed-chunk-23-2.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co">#plot(lm5, which = 3)</span>
lm5 <span class="op">%&gt;.%</span>
<span class="st">  </span><span class="kw">chart</span>(broom<span class="op">::</span><span class="kw">augment</span>(.), <span class="kw">sqrt</span>(<span class="kw">abs</span>(.std.resid)) <span class="op">~</span><span class="st"> </span>.fitted) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">se =</span> <span class="ot">FALSE</span>, <span class="dt">method =</span> <span class="st">&quot;loess&quot;</span>, <span class="dt">formula =</span> y <span class="op">~</span><span class="st"> </span>x) <span class="op">+</span>
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">&quot;Fitted values&quot;</span>,
    <span class="dt">y =</span> <span class="kw">expression</span>(<span class="kw">bold</span>(<span class="kw">sqrt</span>(<span class="kw">abs</span>(<span class="st">&quot;Standardized residuals&quot;</span>))))) <span class="op">+</span>
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Scale-Location&quot;</span>) </code></pre>
<p><img src="02-reg-lineaire-2_files/figure-html/unnamed-chunk-23-3.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co">#plot(lm5, which = 4)</span>
lm5 <span class="op">%&gt;.%</span>
<span class="st">  </span><span class="kw">chart</span>(broom<span class="op">::</span><span class="kw">augment</span>(.), .cooksd <span class="op">~</span><span class="st"> </span><span class="kw">seq_along</span>(.cooksd)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_bar</span>(<span class="dt">stat =</span> <span class="st">&quot;identity&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_hline</span>(<span class="dt">yintercept =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="fl">0.1</span>, <span class="dt">by =</span> <span class="fl">0.05</span>), <span class="dt">colour =</span> <span class="st">&quot;darkgray&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">&quot;Obs. number&quot;</span>, <span class="dt">y =</span> <span class="st">&quot;Cook&#39;s distance&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Cook&#39;s distance&quot;</span>) </code></pre>
<p><img src="02-reg-lineaire-2_files/figure-html/unnamed-chunk-23-4.png" width="672" style="display: block; margin: auto;" /></p>
<p>Naturellement, même si c’est le cas ici, ce n’est pas toujours le modèle le plus complexe qui “gagne” toujours. Même ici, nous pourrions nous demander si le modèle polynomial utilisant uniquement le diamètre ne serait pas plus intéressant en pratique car son ajustement est tout de même relativement bon (même si son critère d’Akaike est nettement moins en sa faveur), mais d’un point de vue pratique, il nous dispense de devoir mesurer la hauteur des arbres pour prédire le volume de bois. Ce n’est peut-être pas négligeable comme gain, pour une erreur de prédiction légèrement supérieure si on compare les valeurs de RMSE.</p>
<pre class="sourceCode r"><code class="sourceCode r">modelr<span class="op">::</span><span class="kw">rmse</span>(lm5, trees) <span class="co"># Multiple et polynomial</span></code></pre>
<pre><code># [1] 0.06939391</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">modelr<span class="op">::</span><span class="kw">rmse</span>(lm3, trees) <span class="co"># Polynomial diamètre</span></code></pre>
<pre><code># [1] 0.08972287</code></pre>
<p>L’erreur moyenne d’estimation du volume de bois passe de 0,07 m<sup>3</sup> pour le modèle le plus complexe <code>lm5</code> utilisant à la fois le diamètre et la hauteur à 0,09 m<sup>3</sup>. C’est à l’exploitant qu’il appartient de déterminer si le gain de précision vaut la peine de devoir effectuer deux mesures au lieu d’une seule. Mais au moins, nous sommes capables, en qualité de scientifiques des données, de lui proposer les alternatives possible et d’en quantifier les effets respectifs.</p>
<!-- TODO: discuter également le cas du jeu de données ANSCOMBE pour montrer les biais qui peuvent apparaitre si on ne visualise pas l'ajustement du modèle sur un graphique-->
<center>
<div class="figure">
<img src="https://imgs.xkcd.com/comics/curve_fitting.png" alt="Différentes méthodes d’ajustement par xkcd." />
<p class="caption"><a href="https://xkcd.com/2048/">Différentes méthodes d’ajustement par xkcd</a>.</p>
</div>
</center>
<div id="a-vous-de-jouer-4" class="section level5 unnumbered">
<h5>A vous de jouer !</h5>
<p>Après cette longue lecture avec énormément de nouvelles matières, nous vous proposons les exercices suivants :</p>
<ul>
<li>Répondez aux questions d’un learnr afin de vérifier vos acquis.</li>
</ul>

<div class="bdd">
<p>Démarrez la SciViews Box et RStudio. Dans la fenêtre <strong>Console</strong> de RStudio, entrez l’instruction suivante suivie de la touche <code>Entrée</code> pour ouvrir le tutoriel concernant les bases de R :</p>
<pre><code>BioDataScience2::run(&quot;02b_reg_poly&quot;)</code></pre>
N’oubliez pas d’appuyer sur la touche <code>ESC</code> pour reprendre la main dans R à la fin d’un tutoriel dans la console R.
</div>

<ul>
<li>Réalisez un carnet de laboratoire sur la biométrie des oursins avec l’assignation ci-dessous.</li>
</ul>

<div class="bdd">
<p>Vous avez à votre disposition une assignation GitHub Classroom :</p>
<ul>
<li><p><a href="https://classroom.github.com/a/5hI-HSOv" class="uri">https://classroom.github.com/a/5hI-HSOv</a></p>
</div></li>
<li><p>Réalisez un rapport scientifique sur la croissance des escargots géants d’Afrique.</p></li>
</ul>

<div class="bdd">
<p>Vous avez à votre disposition une assignation GitHub Classroom :</p>
<ul>
<li><p><a href="https://classroom.github.com/a/_wJZDbNp" class="uri">https://classroom.github.com/a/_wJZDbNp</a></p>
</div></li>
</ul>

<h1 id="mod-lineaire">Modèle linéaire</h1>
<h5 id="objectifs-2" class="unnumbered">Objectifs</h5>
<ul>
<li><p>Comprendre le modèle linéaire (ANOVA et régression linéaire tout en un)</p></li>
<li><p>Appréhender la logique des matrices de contraste</p></li>
<li><p>Découvrir l’ANCOVA</p></li>
<li><p>Comprendre le mécanisme du modèle linéaire généralisé</p></li>
</ul>
<h5 id="prerequis-2" class="unnumbered">Prérequis</h5>
<ul>
<li>L’ANOVA (modules 10 &amp; 11 du cours <a href="http://biodatascience-course.sciviews.org/sdd-umons/">SDD 1</a>), ainsi que la régression linéaires (modules 1 et 2 du présent cours) doivent être maitrisés avant d’aborder cette matière.</li>
</ul>
<h2 id="variables-numeriques-ou-facteurs">Variables numériques ou facteurs</h2>
<p>L’ANOVA analyse une <strong>variable dépendante numérique</strong> en fonction d’une ou plusieurs <strong>variables indépendantes qualitatives</strong>. Ces variables sont dites “facteurs” non ordonnés (objets de classe <code>factor</code>), ou “facteurs” ordonnés (objets de classe <code>ordered</code>) dans R.</p>
<p>La régression linéaire analyse une <strong>variable dépendante numérique</strong> en fonction d’une ou plusieurs <strong>variables indépendantes numérique</strong> (quantitatives) également. Ce sont des objets de classe <code>numeric</code> (ou éventuellement <code>integer</code>, mais assimilé à <code>numeric</code> concrètement) dans R.</p>
<p>Donc, la principale différence entre ANOVA et régression linéaire telles que nous les avnos abordés jusqu’ici réside dans la <strong>nature</strong> de la ou des variables indépendantes, c’est-à-dire, leur type. Pour rappel, il existe deux grandes catégories de variables : quantitatives et qualitatives, et deux sous-catégories pour chacune d’elle. Cela donne quatyre types principaux de variables, formant plus de 90% des cas rencontrés :</p>
<ul>
<li><p>variables quantitatives continues représentables par des nombres réels (<code>numeric</code> dans R),</p></li>
<li><p>variables quantitatives discrètes pour des dénombrements d’événements finis par exemple, et représentables par des nombres entiers (<code>integer</code> dans R),</p></li>
<li><p>variables qualitatives ordonnées pour des variables prenant un petit nombre de valeurs, mais pouvant être ordonnées de la plus petite à la plus grande (<code>ordered</code> dans R),</p></li>
<li><p>variables qualitatives non ordonnées prenant également un petit nombre de valeurs possibles, mais sans ordre particulier (<code>factor</code> dans R).</p></li>
</ul>

<div class="warning">
<p>Par la suite, un encodage correct des variables sera <em>indispensable</em> afin de distinguer correctement ces différentes situations. En effet, R considèrera automatiquement comment mener l’analyse en fonction de la classe des variables fournies. Donc, si la classe est incorrecte, l’analyse le sera aussi ! Si vous avez des doutes concernant les types de variables, relisez la section <a href="http://biodatascience-course.sciviews.org/sdd-umons/types-de-variables.html">type de variables</a> avant de continuer ici.</p>
</div>
<h2 id="anova-et-regression-lineaire">ANOVA et régression linéaire</h2>
<p>Avez-vous remarqué une ressemblance particulière entre la régression linéaire que nous avons réalisé précédement et l’analyse de variance (ANOVA) ? Les plus observateurs auront mis en avant que la fonction de base dans R est la même dans les deux cas : <code>lm()</code>. Cette fonction est donc capable de traiter aussi bien des variables réponses qualitatives que quantitatives, et effectue alors une ANOVA dans un cas ou une régression linéaire dans l’autre.</p>
<p>Par ailleurs, nous avons vu que l’ANOVA et la régression linéaire se représentent par des modèles semblables :</p>
<ul>
<li><p><span class="math inline">\(y = \mu + \tau_i + \epsilon\)</span> pour l’ANOVA et</p></li>
<li><p><span class="math inline">\(y = \beta_1 + \beta_2 x + \epsilon\)</span> pour la régression linéaire, avec</p></li>
<li><p><span class="math inline">\(\epsilon \sim \mathcal{N}(0, \sigma)\)</span> dans les deux cas.</p></li>
</ul>
<p>Donc, nous retrouvons bien au niveau du modèle mathématique sous-jacent la différence principale entre les deux qui réside dans le type de variable indépendante (ou explicative) :</p>
<ul>
<li>Variable <strong>qualitative</strong> pour l’ANOVA,</li>
<li>Variable <strong>quantitative</strong> pour la régression linéaire.</li>
</ul>
<p>Le calcul est, en réalité, identique en interne. Il est donc possible de généraliser ces deux approches en une seule appelée <strong>modèle linéaire</strong>, mais à condition d’utiliser une astuce pour modifier nos modèles afin qu’ils soient intercompatibles.</p>
<h3 id="modele-lineaire-commun">Modèle linéaire commun</h3>
<p>Le nœud du problème revient donc à transformer nos modèles mathématiques pour qu’ils puissent être fusionnés en un seul. Comment homogénéiser ces deux modèles ?</p>
<ul>
<li><p><span class="math inline">\(y = \mu + \tau_i + \epsilon\)</span> pour l’ANOVA et</p></li>
<li><p><span class="math inline">\(y = \beta_1 + \beta_2 x + \epsilon\)</span> pour la régression linéaire.</p></li>
</ul>
<p>Avant de poursuivre, réfléchisser un peu par vous-même. Quelles sont les différences qu’il faut contourner ? Est-il possible d’effectuer une ou plusieurs transformations des variables pour qu’elles se comportent de manière similaire dans les deux cas ?</p>
<h3 id="reencodage-des-variables-de-lanova">Réencodage des variables de l’ANOVA</h3>
<p>Considérons dans un premier temps, un cas très simple : une ANOVA à un facteur avec une variable indépendante qualitative (<code>factor</code>) à deux niveaux<a href="#fn5" class="footnote-ref" id="fnref5"><sup>5</sup></a>. Nous pouvons écrire :</p>
<p><span class="math display">\[
y = \mu + \tau_1 I_1 + \tau_2 I_2 + \epsilon
\]</span></p>
<p>avec <span class="math inline">\(I_i\)</span>, une variable dite <strong>indicatrice</strong> créée de toute pièce qui prend la valeur 1 lorsque le niveau
correspond à <em>i</em>, et 0 dans tous les autres cas. Vous pouvez vérifier par vous-même que l’équation ci-dessus fonctionnera exactement de la même manière que le modèle utilisé jusqu’ici pour l’ANOVA. En effet, poiur un individu de la population 1, <span class="math inline">\(I_1\)</span> vaut 1 et <span class="math inline">\(\tau_1\)</span> est utilisé, alors que comme <span class="math inline">\(I_2\)</span> vaut 0, <span class="math inline">\(\tau_2\)</span> est annulé dans l’équation car <span class="math inline">\(\tau_2 I_2\)</span> vaut également 0. Et c’est exactement l’inverse qui se produit pour un individu de la population 2, de sorte que c’est <span class="math inline">\(\tau_2\)</span> qui est utilisé cette fois-ci.</p>
<p>Notez que notre nouvelle formulation, à l’aide de variables indicatrices ressemble fortement à la régression linéaire. La seule différence par rapport à cette dernière est que nos variables <span class="math inline">\(I_i\)</span> ne peuvent prendre que des valeurs 0 ou 1 (en tous cas, pour l’instant), alors que les <span class="math inline">\(x_i\)</span> dans la régression linéaire multiple sont des variables quantitatives qui peuvent prendre une infinité de valeurs différentes (nombres réels).</p>
<p>Nouys pouvons encore réécrire notre équation comme suit pour qu’elle se rapproche encore plus de celle de la régression linéaire simple. Passons par l’introduction de deux termes identiques <span class="math inline">\(\tau_1 I_2\)</span> additionné et soustrait, ce qui revient au même qu’en leur absence :</p>
<p><span class="math display">\[
y = \mu + \tau_1 I_1 + \tau_1 I_2 - \tau_1 I_2 + \tau_2 I_2 + \epsilon
\]</span></p>
<ul>
<li>En considérant <span class="math inline">\(\beta_2 = \tau_2 - \tau_1\)</span>, cela donne :</li>
</ul>
<p><span class="math display">\[
y = \mu + \tau_1 I_1 + \tau_1 I_2 + \beta_2 I_2 + \epsilon
\]</span></p>
<ul>
<li>En considérant <span class="math inline">\(\beta_1 = \mu + \tau_1 = \mu + \tau_1 I_1 + \tau_1 I_2\)</span> (car quelle que soit la population à laquelle notre individu appartient, il n’y a jamais qu’une seule des deux valeurs <span class="math inline">\(I_1\)</span> ou <span class="math inline">\(I_2\)</span> non nulle et dans tous les cas le résultat est donc égal à <span class="math inline">\(\tau_1\)</span>), on obtient :</li>
</ul>
<p><span class="math display">\[
y = \beta_1 + \beta_2 I_2 + \epsilon
\]</span></p>
<p>Cette dernière formulation est strictement équivalente au modèle de la régression linéaire simple dans laquelle la variable <span class="math inline">\(x\)</span> a simplement été remplacée par notre variable indicatrice <span class="math inline">\(I_2\)</span>. Ceci se généralise pour une variable indépendante à <span class="math inline">\(k\)</span> niveaux, avec <span class="math inline">\(k - 1\)</span> variables indicatrices au final.</p>

<div class="note">
<p>En prenant soin de réencoder le modèle de l’ANOVA relatif aux variables indépendantes qualitatives, nous pouvons à présent mélanger les termes des deux modèles en un seul : notre fameux modèle linéaire. Nous aurons donc, quelque chose du genre (avec les <span class="math inline">\(x_i\)</span> correspondant aux variables quantitatives et les <span class="math inline">\(I_j\)</span> des variables indicatrices pour les différents niveaux des variables qualitatives) :</p>
<p><span class="math display">\[
y = \beta_1 + \beta_2 x_1 + \beta_3 x_2 + ... + \beta_n I_1 + \beta_{n+1} I_2 ... + \epsilon  
\]</span></p>
</div>
<h2 id="matrice-de-contraste">Matrice de contraste</h2>
<p>La version que nous avons étudié jusqu’ici pour nos variables indicatrices, à savoir, une seule prend la valeur 1 lorsque toutes les autres prend une valeur zéro, n’est qu’un cas particulier de ce qu’on appelle les <strong>contrastes</strong> appliqués à ces variables indicatrices. En réalité, nous pouvons leurs donner bien d’autres valeurs (on parle de <strong>poids</strong>), et cela permettra de considérer dses contrastes différents, eux-mêmes représentatifs de situations différentes.</p>
<p>Afin de mieux comprendre les contrastes appliqués à nos modèles linéaires, les statisticiens ont inventé les <strong>matrices de contrastes</strong>. Ce sont des tableaux à deux entrées indiquant pour chaque niveau de la variable indépendante qualitative quelles sont les valeurs utilisées pour les différentes variables indicatrices présentées en colonne.</p>
<p>Dans le cas de notre version simplifiée du modèle mathématique où nous avons fait disparaitre <span class="math inline">\(I_1\)</span> en l’assimilant à la moyenne <span class="math inline">\(\mu\)</span> pour obteniur <span class="math inline">\(\beta_1\)</span>. Dans le cas où notre variable qualitative a quatre niveaux, nous avons donc le modèle suivant :</p>
<p><span class="math display">\[
y = \beta_1 + \beta_2 I_2 + \beta_3 I_3 + \beta_4 I_4 + \epsilon
\]</span></p>
<p>Cela revient à considérer le premier niveau comme <strong>niveau de référence</strong> et à établir tous les contrastes par rapport à ce niveau de référence. C’est une situation que l’on rencontre fréquemment lorsque nos testons l’effet de différents médicaments ou de différents traitement par rapport à un <strong>contrôle</strong> (pas de traitement, ou placébo). La matrice de contrastes correspondante, dans un cas où on aurait trois traitements en plus du contrôle (donc, notre variable <code>factor</code> à quatre niveaux) s’obteint facilement dans R à l’aide de la fonction <code>contr.treatment()</code> :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">contr.treatment</span>(<span class="dv">4</span>)</code></pre>
<pre><code>#   2 3 4
# 1 0 0 0
# 2 1 0 0
# 3 0 1 0
# 4 0 0 1</code></pre>
<p>Les lignes de cette matrice sobnt numérotées de 1 à 4. Elles correspondent aux quatres niveaux de notre variable <code>factor</code>, avec <strong>le niveau 1 qui doit nécessairement correspondre à la situation de référtence, donc au contrôle</strong>.</p>
<p>Les colonnes de cette matrice correspondent aux trois variables indicatrices <span class="math inline">\(I_1\)</span>, <span class="math inline">\(I_2\)</span> et <span class="math inline">\(I_3\)</span> de l’équation au dessus. Nous voyons que pour une individu contrôle, de niveau 1, les trois <span class="math inline">\(I_i\)</span> prennent la valeur 0. Nous sommes bien dans la situation de référence. En d’autres terme, le modèle de base est ajusté sur la moyenne des individus contrôle. Notre modèle se réduit à : <span class="math inline">\(y = \beta_1 + \epsilon\)</span>. Donc, seule la moyenne des individus contrôles, <span class="math inline">\(\beta_1\)</span> est considérée, en plus des résidus <span class="math inline">\(\epsilon\)</span> bien sûr.</p>
<p>Pour le niveau deux, nous observons que <span class="math inline">\(I_2\)</span> vaut 1 et les deux autres <span class="math inline">\(I_i\)</span> valent 0. Donc, cela revient à considérer un décalage constant <span class="math inline">\(\beta_2\)</span> appliqué par rapport au modèle de référence matérialisé par <span class="math inline">\(\beta_1\)</span>. En effezt, notre équation se réduit dans ce cas à : <span class="math inline">\(y = \beta_1 + \beta_2 + \epsilon\)</span>.</p>
<p>Le même raisonnement peut être fait pour les niveaux 3 et 4, avec des décalages constants par rapport à la situation cxontrôle de respectivement <span class="math inline">\(\beta_3\)</span> et <span class="math inline">\(\beta_4\)</span>.</p>
<p>En d’autres termes, les contrastes qui sont construits ici <em>font tous référence au contrôle</em>, et chaque médicament est explicitement comparté au contrôle (mais les médicaments ne sont pas comparés entre eux). Nous voyons donc que les variables indicatrices etr la matrice de contrastes permet de spécifier quelles sont les contrastes pertinents et éliminent ceux qui ne le sont pas (nous n’utilisons donc pas systématiquement toutes les comparaisons deux à deux des différents niveaux<a href="#fn6" class="footnote-ref" id="fnref6"><sup>6</sup></a>).</p>
<h3 id="contraste-orthogonaux">Contraste orthogonaux</h3>
<p>Les contrastes doivent être de préférence <strong>orthogonaux par rapport à l’ordonnée à l’origine</strong>, ce qui signifie que la somme de leurs pondérations doit être nulle pour tous les contrastes définis (<em>donc, en colonnes</em>). Bien que n’étant pas obligatoire, cela confère des propriétés intéressantes au modèle (l’explication et la démonstration sortent du cadre de ce cours). Or, les contrastes de type traitement ne sont <em>pas</em> orthogonaux puisque toutes les sommes par colonnes vaut un.</p>
<h3 id="autres-matrices-de-contrastes-courantes">Autres matrices de contrastes courantes</h3>
<ul>
<li>Somme à zéro. Ces constraste, toujours pour une variable à quatre niveaux, se définissen t comme suit en utilisant la fonction <code>contr.sum()</code> dans R :</li>
</ul>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">contr.sum</span>(<span class="dv">4</span>)</code></pre>
<pre><code>#   [,1] [,2] [,3]
# 1    1    0    0
# 2    0    1    0
# 3    0    0    1
# 4   -1   -1   -1</code></pre>
<p>Ici nous avons bien des contrastes orthogonaux puisque toutes les sommes par colonnes valeur zéro. Dans le cas présent, aucun niveau n’est considéré comme référence, mais les <em>n</em> - 1 niveaux sont systématiquement <strong>contrastés</strong> avec le dernier et <em>n</em>îème^ niveau. Ainsi, un contraste entre deux niveaux particuliers peut s’élaborer en indiquant une pondération de 1 pour le premier niveau à comparer, une pondération de -1 pour le second à comparer et une pondération de 0 pour tous les autres.</p>
<ul>
<li>Matrice de contrastes de Helmert : chaque niveau est comparé à la
moyenne des niveaux précédents. La matrice de constrastes correspondant pour une variable à quatre niveaux s’obtient à l’aide de la fonction R <code>contr.helmert()</code> :</li>
</ul>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">contr.helmert</span>(<span class="dv">4</span>)</code></pre>
<pre><code>#   [,1] [,2] [,3]
# 1   -1   -1   -1
# 2    1   -1   -1
# 3    0    2   -1
# 4    0    0    3</code></pre>
<p>Cette matrice est également orthogonale avec toutes les sommes par colonnes qui valent zéro. Ici, nous découvrons qu’il est possible de créer un contrastye entre un niveau et la moyenne de plusieurs autres niveaux en mettant le poids du premier à m (le nombre de populations à comparer de l’autre côté du contraste), et les poids des autres populations tous à -1. Ainsi, la colonne 4 compare le niveau quatre avec pondération 3 aux trois autres niveaux qui reçoivent tous une pondération -1.</p>
<ul>
<li>Matrice de contrastes polynomiaux : adapté aux facteurs ordonnés (<code>ordered</code> dans R) pourvlesquels on s’attend à une certaine évolution du modèle du niveau le
plus petit au plus grand. Donc ici aussi une comparaison deux à deux de tous les niveaux n’est pas souhaitable, mais une progression d’un effet qui se propage de manière graduelle du plus petit niveau au plus grand. <em>A priori</em> cela parait difficile à métérialiser dans une matrice de contraste… et pourtant, c’est parfaitement possible ! Il s’agit de constrastes polynomiaux où nous ajustons de polynomes de degré croissant comme pondération des différents contrastes étudiés. La fonction <code>contr.poly()</code> permet d’obtenir ce type de contraste dans R. Pour une variable ordonnée à quatre niveaux, cela donne :</li>
</ul>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">contr.poly</span>(<span class="dv">4</span>)</code></pre>
<pre><code>#              .L   .Q         .C
# [1,] -0.6708204  0.5 -0.2236068
# [2,] -0.2236068 -0.5  0.6708204
# [3,]  0.2236068 -0.5 -0.6708204
# [4,]  0.6708204  0.5  0.2236068</code></pre>
<p>Ici, les pondérations sont plus difficiles à expliquer rien qu’en observant la matrice de contrastes. De plus, les colonnes portent ici des noms particuliers <code>.L</code> pour un contraste linéaire (polynome d’ordre 1), <code>.Q</code> pour un contraste quadratique (polynome d’ordre 2), et <code>.C</code> pour un contraste conique (ou polynome d’ordre 3). Les pondérations appliquées se comprennent mieux lorsqu’on augmente le nombre de niveaux etr que l’on représente graphiquement la valeur des pondérations choisées. Par exemple, pour une variable facteur ordonnée à dix niveaux, nous représentrons graphiquement les 3 premeirs contrastes (linéaire, quadratique et conique) comme suit :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(<span class="kw">contr.poly</span>(<span class="dv">10</span>)[, <span class="dv">1</span>], <span class="dt">type =</span> <span class="st">&quot;b&quot;</span>)</code></pre>
<p><img src="03-mod-lineaire_files/figure-html/unnamed-chunk-7-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(<span class="kw">contr.poly</span>(<span class="dv">10</span>)[, <span class="dv">2</span>], <span class="dt">type =</span> <span class="st">&quot;b&quot;</span>)</code></pre>
<p><img src="03-mod-lineaire_files/figure-html/unnamed-chunk-7-2.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(<span class="kw">contr.poly</span>(<span class="dv">10</span>)[, <span class="dv">3</span>], <span class="dt">type =</span> <span class="st">&quot;b&quot;</span>)</code></pre>
<p><img src="03-mod-lineaire_files/figure-html/unnamed-chunk-7-3.png" width="672" style="display: block; margin: auto;" /></p>
<p>Sur le graphique, l’axe X nommé <code>index</code> correspiond en réalité à la succession des 10 niveaux de la variable présentés dans l’ordre du plus petit au plus grand. Nous voyons maintenant clairement comment les contrastes sont construits ici. Pour le conbtraste linéaire, on contraste les petits niveaux avec les grands, et ce, de manière proportionnelle par rapport à la progression d’un niveau à l’autre (polynome d’ordre un = droite). Pour le contraste quadratique, on place “dans le même sac” les petits et greand niveaux qui sont contrastés avec les niveaux moyens (nous avons une parabole ou polynome d’ordre 2). Pour le troisième graphique, la situation se complexifie en encore un peu plus avec un polynome d’ordre 3, et ainsi de suite pour des polynomes d’ordres croissants jusqu’à remplir complètement la matrice de contrastes.</p>

<div class="note">
<p>R utilise par défaut des <strong>contrastes de traitement pour les facteurs non ordonnés</strong> et des <strong>contrastes polynomiaux pour des facteurs ordonnés</strong>. Ces valeurs par défaut sont stockées dans l’option <code>contrasts</code> que l’on peut lire à l’aide de <code>getOption()</code>.</p>
<p>Bien sûr, il est possible de changer ces contrastes, tant au niveau global qu’au niveau de la construction d’un modèle en particulier.</p>
</div>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getOption</span>(<span class="st">&quot;contrasts&quot;</span>)</code></pre>
<pre><code>#         unordered           ordered 
# &quot;contr.treatment&quot;      &quot;contr.poly&quot;</code></pre>
<h2 id="ancova">ANCOVA</h2>
<p>Avant l’apparition du modèle linéaire, une version particulière d’un mélange de régression linéaire et d’une ANOVA avec une variable indépendante quantitative et une autre variable indépendante qualitative s’appelait une ANCOVA (ANalyse de la COVariance). Un tel modèle d’ANCOVA peut naturellement également se résoudre à l’aide de la fonction <code>lm()</code> qui, en outre, peut faire bien plus. Nous allons maintenant ajuster un tel modèle à titre de première application concrète de tout ce que nous venons de voir sur le modèle linéaire et sur les matrices de contrastes associées.</p>
<h3 id="bebes-a-la-naissance">Bébés à la naissance</h3>
<p>Nous étudions la masse de nouveaux nés en fonction du poids de la mère et du fait qu’elle fume ou non. Cette analyse s’inspire de <span class="citation">Verzani (<a href="#ref-verzani2005">2005</a>)</span>. Nous avons donc ici une variable dépendante <code>wt</code>, la masse des bébés qui est quantitative, et deux variables indépendantes ou prédictives <code>wt1</code>, la masse de la mère, et <code>smoke</code> le fait que la mère fume ou non. Or la première de ces variables explicatives est quantitative (<code>wt1</code>) et l’autre (<code>smoke</code>) est une variable facteur à quatre niveaux (0 = la mère n’a jamais fumé, 1 = elle fume y compris pendant la grossesse, 2 = elle fumait mais a arrêté à la grossesses, et 3 = la mère a fumé, mais a arrêté, et ce, bien avant la grossesse. Un dernier niveau 9 = inconnu encode de manière non orthodoxe les valeurs manquantes dans notre tableau de données (valeurs que nous éliminerons). De même les masses des nouveaux nés et des mères sont des des unités impériales (américaines) respectivement en “onces” et en “livres”. Enfin, nous devons prendre soin de bien encoder la variable <code>smoke</code> comme une variable <code>factor</code> (ici nous ne considèrerons pas qu’il s’agit d’un facteur ordonné et nous voulons faire un contraste de type traitement avec comparaison à des mères qui n’ont jamais fumé). <strong>Un reminement soigneux des données est donc nécessaire avant de pouvoir appliquer notre modèle !</strong></p>
<pre class="sourceCode r"><code class="sourceCode r">SciViews<span class="op">::</span>R
babies &lt;-<span class="st"> </span><span class="kw">read</span>(<span class="st">&quot;babies&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;UsingR&quot;</span>)
knitr<span class="op">::</span><span class="kw">kable</span>(<span class="kw">head</span>(babies))</code></pre>
<table>
<thead>
<tr class="header">
<th align="right">id</th>
<th align="right">pluralty</th>
<th align="right">outcome</th>
<th align="right">date</th>
<th align="right">gestation</th>
<th align="right">sex</th>
<th align="right">wt</th>
<th align="right">parity</th>
<th align="right">race</th>
<th align="right">age</th>
<th align="right">ed</th>
<th align="right">ht</th>
<th align="right">wt1</th>
<th align="right">drace</th>
<th align="right">dage</th>
<th align="right">ded</th>
<th align="right">dht</th>
<th align="right">dwt</th>
<th align="right">marital</th>
<th align="right">inc</th>
<th align="right">smoke</th>
<th align="right">time</th>
<th align="right">number</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">15</td>
<td align="right">5</td>
<td align="right">1</td>
<td align="right">1411</td>
<td align="right">284</td>
<td align="right">1</td>
<td align="right">120</td>
<td align="right">1</td>
<td align="right">8</td>
<td align="right">27</td>
<td align="right">5</td>
<td align="right">62</td>
<td align="right">100</td>
<td align="right">8</td>
<td align="right">31</td>
<td align="right">5</td>
<td align="right">65</td>
<td align="right">110</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">20</td>
<td align="right">5</td>
<td align="right">1</td>
<td align="right">1499</td>
<td align="right">282</td>
<td align="right">1</td>
<td align="right">113</td>
<td align="right">2</td>
<td align="right">0</td>
<td align="right">33</td>
<td align="right">5</td>
<td align="right">64</td>
<td align="right">135</td>
<td align="right">0</td>
<td align="right">38</td>
<td align="right">5</td>
<td align="right">70</td>
<td align="right">148</td>
<td align="right">1</td>
<td align="right">4</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td align="right">58</td>
<td align="right">5</td>
<td align="right">1</td>
<td align="right">1576</td>
<td align="right">279</td>
<td align="right">1</td>
<td align="right">128</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">28</td>
<td align="right">2</td>
<td align="right">64</td>
<td align="right">115</td>
<td align="right">5</td>
<td align="right">32</td>
<td align="right">1</td>
<td align="right">99</td>
<td align="right">999</td>
<td align="right">1</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="right">61</td>
<td align="right">5</td>
<td align="right">1</td>
<td align="right">1504</td>
<td align="right">999</td>
<td align="right">1</td>
<td align="right">123</td>
<td align="right">2</td>
<td align="right">0</td>
<td align="right">36</td>
<td align="right">5</td>
<td align="right">69</td>
<td align="right">190</td>
<td align="right">3</td>
<td align="right">43</td>
<td align="right">4</td>
<td align="right">68</td>
<td align="right">197</td>
<td align="right">1</td>
<td align="right">8</td>
<td align="right">3</td>
<td align="right">5</td>
<td align="right">5</td>
</tr>
<tr class="odd">
<td align="right">72</td>
<td align="right">5</td>
<td align="right">1</td>
<td align="right">1425</td>
<td align="right">282</td>
<td align="right">1</td>
<td align="right">108</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">23</td>
<td align="right">5</td>
<td align="right">67</td>
<td align="right">125</td>
<td align="right">0</td>
<td align="right">24</td>
<td align="right">5</td>
<td align="right">99</td>
<td align="right">999</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
<td align="right">5</td>
</tr>
<tr class="even">
<td align="right">100</td>
<td align="right">5</td>
<td align="right">1</td>
<td align="right">1673</td>
<td align="right">286</td>
<td align="right">1</td>
<td align="right">136</td>
<td align="right">4</td>
<td align="right">0</td>
<td align="right">25</td>
<td align="right">2</td>
<td align="right">62</td>
<td align="right">93</td>
<td align="right">3</td>
<td align="right">28</td>
<td align="right">2</td>
<td align="right">64</td>
<td align="right">130</td>
<td align="right">1</td>
<td align="right">4</td>
<td align="right">2</td>
<td align="right">2</td>
<td align="right">2</td>
</tr>
</tbody>
</table>
<p>Ce tableau est “brut de décoffrage”. Voyez <code>help(&quot;babies&quot;, package = &quot;UsingR&quot;)</code> pour de plus amples informations. Nous allons maintenant remanier tout cela correctement.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># wt = masse du bébé à la naissance en onces et 999 = valeur manquante</span>
<span class="co"># wt1 = masse de la mère à la naissance en livres et 999 = valeur manquante</span>
<span class="co"># smoke = 0 (non), = 1 (oui), = 2 (jusqu&#39;à grossesse),</span>
<span class="co">#       = 3 (plus depuis un certain temps) and = 9 (inconnu)</span>
babies <span class="op">%&gt;.%</span><span class="st"> </span><span class="kw">select</span>(., wt, wt1, smoke) <span class="op">%&gt;.%</span><span class="st"> </span><span class="co"># Garder seulement wt, wt1 &amp; smoke</span>
<span class="st">  </span><span class="kw">filter</span>(., wt1 <span class="op">&lt;</span><span class="st"> </span><span class="dv">999</span>, wt <span class="op">&lt;</span><span class="st"> </span><span class="dv">999</span>, smoke <span class="op">&lt;</span><span class="st"> </span><span class="dv">9</span>) <span class="op">%&gt;.%</span><span class="st"> </span><span class="co"># Eliminer les valeurs manquantes</span>
<span class="st">  </span><span class="kw">mutate</span>(., <span class="dt">wt =</span> wt <span class="op">*</span><span class="st"> </span><span class="fl">0.02835</span>) <span class="op">%&gt;.%</span><span class="st"> </span><span class="co"># Transformer le poids en kg</span>
<span class="st">  </span><span class="kw">mutate</span>(., <span class="dt">wt1 =</span> wt1 <span class="op">*</span><span class="st"> </span><span class="fl">0.4536</span>) <span class="op">%&gt;.%</span><span class="st"> </span><span class="co"># Idem</span>
<span class="st">  </span><span class="kw">mutate</span>(., <span class="dt">smoke =</span> <span class="kw">as.factor</span>(smoke)) -&gt;<span class="st"> </span><span class="co"># S&#39;assurer d&#39;avoir une variable factor</span>
<span class="st">  </span>Babies <span class="co"># Enregistrer le résultat dans Babies</span>

knitr<span class="op">::</span><span class="kw">kable</span>(<span class="kw">head</span>(Babies))</code></pre>
<table>
<thead>
<tr class="header">
<th align="right">wt</th>
<th align="right">wt1</th>
<th align="left">smoke</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">3.40200</td>
<td align="right">45.3600</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="right">3.20355</td>
<td align="right">61.2360</td>
<td align="left">0</td>
</tr>
<tr class="odd">
<td align="right">3.62880</td>
<td align="right">52.1640</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="right">3.48705</td>
<td align="right">86.1840</td>
<td align="left">3</td>
</tr>
<tr class="odd">
<td align="right">3.06180</td>
<td align="right">56.7000</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="right">3.85560</td>
<td align="right">42.1848</td>
<td align="left">2</td>
</tr>
</tbody>
</table>
<p>Description des données :</p>
<pre class="sourceCode r"><code class="sourceCode r">skimr<span class="op">::</span><span class="kw">skim</span>(Babies)</code></pre>
<pre><code># Skim summary statistics
#  n obs: 1190 
#  n variables: 3 
# 
# ── Variable type:factor ──────────────────────────────────────────────────────────────────
#  variable missing complete    n n_unique                    top_counts
#     smoke       0     1190 1190        4 0: 531, 1: 465, 3: 102, 2: 92
#  ordered
#    FALSE
# 
# ── Variable type:numeric ─────────────────────────────────────────────────────────────────
#  variable missing complete    n  mean   sd    p0   p25  p50   p75   p100
#        wt       0     1190 1190  3.39 0.52  1.56  3.06  3.4  3.71   4.99
#       wt1       0     1190 1190 58.3  9.49 39.46 51.82 56.7 62.6  113.4 
#      hist
#  ▁▁▂▆▇▅▁▁
#  ▂▇▆▂▁▁▁▁</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">chart</span>(<span class="dt">data =</span> Babies, wt <span class="op">~</span><span class="st"> </span>wt1 <span class="op">%col=%</span><span class="st"> </span>smoke) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;Masse de la mère [kg]&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;Masse du bébé [kg]&quot;</span>)</code></pre>
<p><img src="03-mod-lineaire_files/figure-html/unnamed-chunk-13-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">chart</span>(<span class="dt">data =</span> Babies, wt <span class="op">~</span><span class="st"> </span>smoke) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_boxplot</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;Masse du bébé [kg]&quot;</span>)</code></pre>
<p><img src="03-mod-lineaire_files/figure-html/unnamed-chunk-14-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">chart</span>(<span class="dt">data =</span> Babies, wt1 <span class="op">~</span><span class="st"> </span>smoke) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_boxplot</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;Masse de la mère [kg]&quot;</span>)</code></pre>
<p><img src="03-mod-lineaire_files/figure-html/unnamed-chunk-15-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Visuellement, nous ne voyons pas d’effet marquant. Peut-être la condition 1 de <code>smoke</code> (mère qui fume pendant la grossesse) mène-t-il à des bébés moins gros, mais est-ce significatif ? Pour cela, ajustons notre modèle ANCOVA avec matrice traitement (choix par défaut pour une la variable <code>factor</code> <code>smoke</code>). Comme nous savons déjà utiliser <code>lm()</code>, c’est très simple. Cela fonctionne exactement comme avant<a href="#fn7" class="footnote-ref" id="fnref7"><sup>7</sup></a>.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># ANCOVA</span>
Babies_lm &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="dt">data =</span> Babies, wt <span class="op">~</span><span class="st"> </span>smoke <span class="op">*</span><span class="st"> </span>wt1)
<span class="kw">summary</span>(Babies_lm)</code></pre>
<pre><code># 
# Call:
# lm(formula = wt ~ smoke * wt1, data = Babies)
# 
# Residuals:
#     Min      1Q  Median      3Q     Max 
# -1.9568 -0.3105  0.0133  0.3136  1.4989 
# 
# Coefficients:
#              Estimate Std. Error t value Pr(&gt;|t|)    
# (Intercept)  3.000663   0.128333  23.382  &lt; 2e-16 ***
# smoke1      -0.303614   0.196930  -1.542 0.123405    
# smoke2       0.901888   0.371393   2.428 0.015314 *  
# smoke3      -0.035502   0.371379  -0.096 0.923858    
# wt1          0.008117   0.002149   3.777 0.000167 ***
# smoke1:wt1   0.001153   0.003346   0.345 0.730444    
# smoke2:wt1  -0.015340   0.006390  -2.401 0.016523 *  
# smoke3:wt1   0.001177   0.006147   0.191 0.848258    
# ---
# Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
# 
# Residual standard error: 0.4992 on 1182 degrees of freedom
# Multiple R-squared:  0.08248, Adjusted R-squared:  0.07705 
# F-statistic: 15.18 on 7 and 1182 DF,  p-value: &lt; 2.2e-16</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">anova</span>(Babies_lm)</code></pre>
<pre><code># Analysis of Variance Table
# 
# Response: wt
#             Df  Sum Sq Mean Sq F value    Pr(&gt;F)    
# smoke        3  18.659  6.2197 24.9636 1.158e-15 ***
# wt1          1   6.162  6.1621 24.7325 7.559e-07 ***
# smoke:wt1    3   1.653  0.5511  2.2117   0.08507 .  
# Residuals 1182 294.497  0.2492                      
# ---
# Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>L’analyse de variance montre que la masse de la mère a un effet significatif au seuil alpha de 5%, de même si la mère fume. Par contre, il n’y a pas d’<strong>interactions</strong> entre les deux. Le fait de pouvoir meurer des interactions entre variables qualitatives et quantitatives est ici bien évidemment un plus du modèle linéaire par rapport à ce qu’on pouvait faire avant !</p>
<p>Le résumé de l’analyse nous montre que la régression de la masse des bébés en fonction de la masse de la mère (ligne <code>wt1</code> dans le tableau des coefficients), bien qu’étant significative, n’explique que 8% de la variance totale (le <span class="math inline">\(R^2\)</span>). Les termes <code>smoke1</code>, <code>smoke2</code> et <code>smoke3</code> sont les contrastes appliqués par rapport au contrôle (<code>smoke == 0</code>). On voit ici qu’aucun de ces contrastes n’est significatif au seuil alpha de 5%. Cela signifie que le seul effet significatif est celui lié à une ordonnée à l’origine non nulle <code>(Intercept)</code> matérialisant la condition <code>smoke == 0</code>. Cela signifie que des mères de masse nulle n’ayant jamais fumé engendreraient des bébés pesant environ 3kg. Dans le contexte présent, cette constatation n’a bien sûr aucun sens, et l’interprétation de l’ordonnée à l’origine ne doit pas être faite. Donc, le modèle linéaire, en offrant plus de contrôle dans notre ajustement et une définition de contrastes “utiles” matérialisés par les lignes <code>smoke1</code>, <code>smoke2</code> et <code>smoke3</code> du tableau nous permet de faire des tests plus utiles dans le contexte de notre analyse.</p>
<p>N’oublions pas non plus la possibilité de déterminer si des interactions entre <code>smoke</code> et <code>wt1</code> existent pour ces différents contrastes, interactions testées respectivements aux lignes <code>smoke1:wt1</code>, <code>smoke2:wt1</code>, et <code>smoke3:wt1</code>du tableau des coefficients. Dans le cas présent, aucune de ces interactions n’est siginificative au seuil alpha de 5%.</p>
<p>Pour comprendre à quoi tout cela fait référence, il faut considérer le modèle de base comme une droite de régression ajustée entre <code>wt</code> et <code>wt1</code> pour la population de référence <code>smoke == 0</code>. Ainsi, si nous faisons :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(<span class="kw">lm</span>(<span class="dt">data =</span> Babies, wt <span class="op">~</span><span class="st"> </span>wt1, <span class="dt">subset =</span> smoke <span class="op">==</span><span class="st"> </span><span class="dv">0</span>))</code></pre>
<pre><code># 
# Call:
# lm(formula = wt ~ wt1, data = Babies, subset = smoke == 0)
# 
# Residuals:
#      Min       1Q   Median       3Q      Max 
# -1.95685 -0.25825  0.01476  0.25464  1.49890 
# 
# Coefficients:
#             Estimate Std. Error t value Pr(&gt;|t|)    
# (Intercept) 3.000663   0.123572  24.283  &lt; 2e-16 ***
# wt1         0.008117   0.002069   3.922 9.92e-05 ***
# ---
# Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
# 
# Residual standard error: 0.4806 on 529 degrees of freedom
# Multiple R-squared:  0.02826, Adjusted R-squared:  0.02642 
# F-statistic: 15.38 on 1 and 529 DF,  p-value: 9.924e-05</code></pre>
<p>Nous voyons en effet que les pentes et ordonnées à l’origine sont ici parfaitement identiques au modèle ANCOVA complet (mais pas les tests associés).</p>
<p>Maintenant plus difficile : à quoi correspond une régression entre <code>wt</code> et <code>wt1</code> pour <code>smoke == 1</code> ?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(<span class="kw">lm</span>(<span class="dt">data =</span> Babies, wt <span class="op">~</span><span class="st"> </span>wt1, <span class="dt">subset =</span> smoke <span class="op">==</span><span class="st"> </span><span class="dv">1</span>))</code></pre>
<pre><code># 
# Call:
# lm(formula = wt ~ wt1, data = Babies, subset = smoke == 1)
# 
# Residuals:
#      Min       1Q   Median       3Q      Max 
# -1.70870 -0.35089  0.01034  0.33576  1.39420 
# 
# Coefficients:
#             Estimate Std. Error t value Pr(&gt;|t|)    
# (Intercept) 2.697048   0.153270  17.597  &lt; 2e-16 ***
# wt1         0.009270   0.002632   3.522 0.000471 ***
# ---
# Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
# 
# Residual standard error: 0.5122 on 463 degrees of freedom
# Multiple R-squared:  0.02609, Adjusted R-squared:  0.02399 
# F-statistic:  12.4 on 1 and 463 DF,  p-value: 0.0004711</code></pre>
<p>Nous avons une ordonnées à l’origine qui vaut 2,70 ici. Notons que cela correspond aussi à <code>(Intercept)</code> + <code>smoke1</code> = 3,00 - 0,30 = 2,70. Donc, l’ordonnées à l’origine pour <code>smoke == 1</code> est bien la valeur de référence additionnée de la valeur fournie à la ligne <code>smoke1</code> dans l’ANCOVA. Cela se vérifie aussi pour les deux autres droites pour <code>smoke2</code> et <code>smoke3</code>.</p>
<p>Maintenant, la pente pour notre droite ajustée sur la population <code>smoke == 1</code> uniquement vaut 0,00927. Dans l’ANCOVA, nous avions une pente <code>wt1</code> de 0,00812 et une interaction <code>smoke1:wt1</code> claculée comme 0,00115. Notez alors que la pente de la droite seule 0,00927 = 0,00812 + 0,00115. Donc, tout comme <code>smoke1</code> correspond au décalage de l’ordonnée à l’origine du modèle de référence, les interactions <code>smoke1:wt1</code> correspondent au décalage de la pente par rapport au modèle de référence. Cela se vérifie également pour <code>smoke2:wt1</code> et <code>smoke3:wt1</code>.</p>
<p>Donc, notre modèle complet ne fait rien d’autre que d’ajuster les quatre droites correspondant aux relations linéaires entre <code>wt</code> et <code>wt1</code>, <strong>mais en décompose les effets, niveau par niveau de la variable qualitative <code>smoke</code></strong> en fonction de la matrice de contraste que l’on a choisie. En bonnus, nous avons la possibilité de tester si chacune des composantes (tableau coefficient de <code>summary()</code>) ou si globalement chacune des variables (tableau obtenu avec <code>anova()</code>) a un effet significatif ou non dans le modèle.</p>
<p>Le graphique correspondant est le même que si nous avions ajusté les 4 régressions linéaires indépendamment l’une de l’autre (mais les tests et les enveloppes de confiance diffèrent).</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">chart</span>(<span class="dt">data =</span> Babies, wt <span class="op">~</span><span class="st"> </span>wt1 <span class="op">%col=%</span><span class="st"> </span>smoke) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">stat_smooth</span>(<span class="dt">method =</span> <span class="st">&quot;lm&quot;</span>, <span class="dt">formula =</span> y <span class="op">~</span><span class="st"> </span>x) <span class="op">+</span>
<span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;Masse de la mère [kg]&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;Masse du bébé [kg]&quot;</span>)</code></pre>
<p><img src="03-mod-lineaire_files/figure-html/unnamed-chunk-19-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">chart</span>(<span class="dt">data =</span> Babies, wt <span class="op">~</span><span class="st"> </span>wt1 <span class="op">|</span><span class="st"> </span>smoke) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">stat_smooth</span>(<span class="dt">method =</span> <span class="st">&quot;lm&quot;</span>, <span class="dt">formula =</span> y <span class="op">~</span><span class="st"> </span>x) <span class="op">+</span>
<span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;Masse de la mère [kg]&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;Masse du bébé [kg]&quot;</span>)</code></pre>
<p><img src="03-mod-lineaire_files/figure-html/unnamed-chunk-20-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Comme toujours, lorsqu’un effet n’est pas siugnificatif, nous pouvons décider de <em>simplifier</em> le modèle. <strong>Mais attention ! Toujours considérer que les composantes sont interdépendantes.</strong> Donc, éliminer une composante du modèle peut avoir des effets parfois surprenants sur les autres.</p>
<p>Voyons ce que cela donne si nous éliminons les interactions. Dans ce cas, nous ajustons des droites toutes parallèles avec uniquement un décalage de leur ordonnée à l’origine matérialisé par <code>smoke1</code>, <code>smoke2</code> et <code>smoke3</code> par rapport au modèle de référence ajusté pour la population <code>smoke == 0</code> (notez l’utilisation, du signe <code>+</code> dans la formuile, là où nous utilisions le signe <code>*</code> dans la modèle précédent).</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># ANCOVA</span>
Babies_lm2 &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="dt">data =</span> Babies, wt <span class="op">~</span><span class="st"> </span>smoke <span class="op">+</span><span class="st"> </span>wt1)
<span class="kw">summary</span>(Babies_lm2)</code></pre>
<pre><code># 
# Call:
# lm(formula = wt ~ smoke + wt1, data = Babies)
# 
# Residuals:
#      Min       1Q   Median       3Q      Max 
# -1.95453 -0.30780  0.01289  0.31108  1.49443 
# 
# Coefficients:
#              Estimate Std. Error t value Pr(&gt;|t|)    
# (Intercept)  3.030052   0.092861  32.630  &lt; 2e-16 ***
# smoke1      -0.237938   0.031816  -7.478 1.46e-13 ***
# smoke2       0.022666   0.056508   0.401    0.688    
# smoke3       0.035486   0.054068   0.656    0.512    
# wt1          0.007617   0.001534   4.966 7.85e-07 ***
# ---
# Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
# 
# Residual standard error: 0.4999 on 1185 degrees of freedom
# Multiple R-squared:  0.07733, Adjusted R-squared:  0.07422 
# F-statistic: 24.83 on 4 and 1185 DF,  p-value: &lt; 2.2e-16</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">anova</span>(Babies_lm2)</code></pre>
<pre><code># Analysis of Variance Table
# 
# Response: wt
#             Df  Sum Sq Mean Sq F value    Pr(&gt;F)    
# smoke        3  18.659  6.2197  24.887 1.285e-15 ***
# wt1          1   6.162  6.1621  24.657 7.853e-07 ***
# Residuals 1185 296.150  0.2499                      
# ---
# Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>Hé, ça c’est intéressant ! Maintenant que nous avons éliminé les interactions qui apparaissent non pertinentes ici, nous avons toujours une régression significative entre <code>wt</code> et <code>wt1</code> (mais avec un <span class="math inline">\(R^2\)</span> très faible de 7,7%, attention), mais maintenant, nous faisons apparaitre un effet signicfication du contraste avec <code>smoke1</code> au seuil alpha de 5%. Et du coup, les effets des deux variables deviennent plus clairs dans notre tableau de l’ANOVA.</p>
<p>Le graphique correspondant est l’ajustement de droites parallèles les unes aux autres pour les 4 sous-populations en fonction de <code>smoke</code>. Ce graphique est difficile à réaliser. Il faut ruser, et les détails du code vont au delà de ce cours (il n’est pas nécessaire de les comprendre à ce stade).</p>
<pre class="sourceCode r"><code class="sourceCode r">cols &lt;-<span class="st"> </span>iterators<span class="op">::</span><span class="kw">iter</span>(scales<span class="op">::</span><span class="kw">hue_pal</span>()(<span class="dv">4</span>)) <span class="co"># Get colors for lines</span>
<span class="kw">chart</span>(<span class="dt">data =</span> Babies, wt <span class="op">~</span><span class="st"> </span>wt1) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">col =</span> smoke)) <span class="op">+</span>
<span class="st">  </span><span class="kw">lapply</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">-0.238</span>, <span class="fl">0.0227</span>, <span class="fl">0.0355</span>), <span class="cf">function</span>(offset)
    <span class="kw">geom_smooth</span>(<span class="dt">method =</span> lm, <span class="dt">formula =</span> y <span class="op">+</span><span class="st"> </span>offset <span class="op">~</span><span class="st"> </span>x,
      <span class="dt">col =</span> iterators<span class="op">::</span><span class="kw">nextElem</span>(cols))) <span class="op">+</span>
<span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;Masse de la mère [kg]&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;Masse du bébé [kg]&quot;</span>)</code></pre>
<p><img src="03-mod-lineaire_files/figure-html/unnamed-chunk-22-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Voyons ce que donne l’analyse <em>post hoc</em> des comparaisons multiples (nous utilisons ici simplement le snippet disponible à partir de <code>...</code> -&gt; <code>hypothesis tests</code> -&gt; <code>hypothesis tests: means</code> -&gt; <code>hmanovamult : anova - multiple comparaisons [multcomp]</code>) que nous avons déjà employé et qui reste valable ici.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(anovaComp. &lt;-<span class="st"> </span><span class="kw">confint</span>(multcomp<span class="op">::</span><span class="kw">glht</span>(Babies_lm2,
  <span class="dt">linfct =</span> multcomp<span class="op">::</span><span class="kw">mcp</span>(<span class="dt">smoke =</span> <span class="st">&quot;Tukey&quot;</span>))))</code></pre>
<pre><code># 
#    Simultaneous Tests for General Linear Hypotheses
# 
# Multiple Comparisons of Means: Tukey Contrasts
# 
# 
# Fit: lm(formula = wt ~ smoke + wt1, data = Babies)
# 
# Linear Hypotheses:
#            Estimate Std. Error t value Pr(&gt;|t|)    
# 1 - 0 == 0 -0.23794    0.03182  -7.478   &lt;1e-04 ***
# 2 - 0 == 0  0.02267    0.05651   0.401    0.977    
# 3 - 0 == 0  0.03549    0.05407   0.656    0.908    
# 2 - 1 == 0  0.26060    0.05704   4.568   &lt;1e-04 ***
# 3 - 1 == 0  0.27342    0.05478   4.991   &lt;1e-04 ***
# 3 - 2 == 0  0.01282    0.07199   0.178    0.998    
# ---
# Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
# (Adjusted p values reported -- single-step method)</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">.oma &lt;-<span class="st"> </span><span class="kw">par</span>(<span class="dt">oma =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">5.1</span>, <span class="dv">0</span>, <span class="dv">0</span>)); <span class="kw">plot</span>(anovaComp.); <span class="kw">par</span>(.oma); <span class="kw">rm</span>(.oma)</code></pre>
<p><img src="03-mod-lineaire_files/figure-html/unnamed-chunk-23-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Ici, comme nous testons tous les contrastes, nous pouvons dire que la population des mères qui ont fumé pendant la grossesse <code>smoke == 1</code> donne des bébés significativement moins gros au seuil alpha de 5%, et ce, en comparaison de tous les autres niveaux (mère n’ayant jamais fumé, ou ayant fumé mais arrêté avant la grossesse, que ce soit longtemps avant ou juste avant).</p>
<p>Il semble évident maintenant qu’il n’est pas utile de préciser si la mère a fumé ou non avant sa grossesse. L’élément déterminant est uniquement le fait de fumer <em>pendant</em> la grossesse ou non. Nous pouvons le montrer également en utilisant des contrastes de Helmert, à condition de recoder <code>smoke</code> avec des niveaux de “gravité” croissants (“0” = n’a jamais fumé, “1” = a arrêté il y a longtemps, “2” = a arrêté juste avant la grossesse et finalement, “1” = a continué à fumé à la grossesse). Il faut donc intervertir les cas “1” et “3”. Nous pouvons utiliser <code>recode()</code> pour cela, mais attention, nous avons ici une variable <code>factor</code>, donc, ce ne sont pas des nombres mais des chaines de caractères (à placer entre guillements). Une fois le recodage réalisé, il faut aussi retrier les niveaux en appelant <code>factor(..., levels = c(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;))</code> sinon l’ancien ordre est conservé.</p>
<pre class="sourceCode r"><code class="sourceCode r">Babies <span class="op">%&gt;.%</span>
<span class="st">  </span><span class="kw">mutate</span>(., <span class="dt">smoke =</span> <span class="kw">recode</span>(smoke, <span class="st">&quot;0&quot;</span> =<span class="st"> &quot;0&quot;</span>, <span class="st">&quot;1&quot;</span> =<span class="st"> &quot;3&quot;</span>, <span class="st">&quot;2&quot;</span> =<span class="st"> &quot;2&quot;</span>, <span class="st">&quot;3&quot;</span> =<span class="st"> &quot;1&quot;</span>)) <span class="op">%&gt;.%</span>
<span class="st">  </span><span class="kw">mutate</span>(., <span class="dt">smoke =</span> <span class="kw">factor</span>(smoke, <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;0&quot;</span>, <span class="st">&quot;1&quot;</span>, <span class="st">&quot;2&quot;</span>, <span class="st">&quot;3&quot;</span>))) -&gt;
<span class="st">  </span>Babies2</code></pre>
<p>Si cela semble trop compliqué, vous pouvez aussi utiliser l’addins de réencodage dans R (<code>QUESTIONR</code> -&gt; <code>Levels Recoding</code> or <code>Levels Ordering</code>). A présent que l’encodage de <code>smoke</code> est corrigé dans <code>Babies2</code>, nous pouvons modéliser à nouveau, mais cette fois-ci avec des contrastes de Helmert (notez la façon particulière de spécifier des contrastes différents de la valeur pas défaut pour une variable <code>factor</code>) :</p>
<pre class="sourceCode r"><code class="sourceCode r">Babies_lm3 &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="dt">data =</span> Babies2, wt <span class="op">~</span><span class="st"> </span>smoke <span class="op">+</span><span class="st"> </span>wt1,
  <span class="dt">contrasts =</span> <span class="kw">list</span>(<span class="dt">smoke =</span> <span class="st">&quot;contr.helmert&quot;</span>))
<span class="kw">summary</span>(Babies_lm3)</code></pre>
<pre><code># 
# Call:
# lm(formula = wt ~ smoke + wt1, data = Babies2, contrasts = list(smoke = &quot;contr.helmert&quot;))
# 
# Residuals:
#      Min       1Q   Median       3Q      Max 
# -1.95453 -0.30780  0.01289  0.31108  1.49443 
# 
# Coefficients:
#              Estimate Std. Error t value Pr(&gt;|t|)    
# (Intercept)  2.985106   0.091695  32.555  &lt; 2e-16 ***
# smoke1       0.017743   0.027034   0.656    0.512    
# smoke2       0.001641   0.019599   0.084    0.933    
# smoke3      -0.064330   0.008540  -7.533 9.82e-14 ***
# wt1          0.007617   0.001534   4.966 7.85e-07 ***
# ---
# Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
# 
# Residual standard error: 0.4999 on 1185 degrees of freedom
# Multiple R-squared:  0.07733, Adjusted R-squared:  0.07422 
# F-statistic: 24.83 on 4 and 1185 DF,  p-value: &lt; 2.2e-16</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">anova</span>(Babies_lm3)</code></pre>
<pre><code># Analysis of Variance Table
# 
# Response: wt
#             Df  Sum Sq Mean Sq F value    Pr(&gt;F)    
# smoke        3  18.659  6.2197  24.887 1.285e-15 ***
# wt1          1   6.162  6.1621  24.657 7.853e-07 ***
# Residuals 1185 296.150  0.2499                      
# ---
# Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>Ici les valeurs estimées pour <code>smoke1-3</code> sont à interpréter en fonction des contrastes utilisés, soit :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">contr.helmert</span>(<span class="dv">4</span>)</code></pre>
<pre><code>#   [,1] [,2] [,3]
# 1   -1   -1   -1
# 2    1   -1   -1
# 3    0    2   -1
# 4    0    0    3</code></pre>
<ul>
<li><code>smoke1</code> est le décalage de l’ordonnée à l’origine entre la modèle moyen établi avec les données <code>smoke == 0</code> et <code>smoke == 1</code> et celui pour <code>smoke == 1</code> (non significatif au seuil alpha de 5%),</li>
<li><code>smoke2</code> est le décalage de l’ordonnée à l’origine pour <code>smoke == 2</code> <em>par rapport au modèle ajusté sur <code>smoke == 0</code>, <code>smoke == 1</code> <strong>et</strong> <code>smoke == 2</code> avec des pondérations respectives de -1, -1, et 2</em> (non significatif au seuil alpha de 5%),</li>
<li><code>smoke3</code> est le décalage de l’ordonnée à l’origine par rapport au modèle ajusté sur l’ensemble des autres observations, donc, avec <code>smoke</code> valant 0, 1, ou 2, et des pondérations respectives comme dans la dernière colonne de la matrice de contraste.. Donc, ce dernier contraste est celui qui nous intéresse car il compare les cas où la mère n’a pas fumé pendant la grossesse avec le cas <code>smoke == 3</code> où la mère a fumé pendant la grossesse, et il est significatif au seuil alpha de 5%. L’interprétation des vlauers estimées est plus complexe ici. Comparer ce résultat avec le modèle ajusté avec les contrastes traitement par défaut avec <code>smoke</code> réencodé :</li>
</ul>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(<span class="kw">lm</span>(<span class="dt">data =</span> Babies2, wt <span class="op">~</span><span class="st"> </span>smoke <span class="op">+</span><span class="st"> </span>wt1))</code></pre>
<pre><code># 
# Call:
# lm(formula = wt ~ smoke + wt1, data = Babies2)
# 
# Residuals:
#      Min       1Q   Median       3Q      Max 
# -1.95453 -0.30780  0.01289  0.31108  1.49443 
# 
# Coefficients:
#              Estimate Std. Error t value Pr(&gt;|t|)    
# (Intercept)  3.030052   0.092861  32.630  &lt; 2e-16 ***
# smoke1       0.035486   0.054068   0.656    0.512    
# smoke2       0.022666   0.056508   0.401    0.688    
# smoke3      -0.237938   0.031816  -7.478 1.46e-13 ***
# wt1          0.007617   0.001534   4.966 7.85e-07 ***
# ---
# Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
# 
# Residual standard error: 0.4999 on 1185 degrees of freedom
# Multiple R-squared:  0.07733, Adjusted R-squared:  0.07422 
# F-statistic: 24.83 on 4 and 1185 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>Les conclusions sont les mêmes, mais la valeurs estimées pour <code>smoke1</code>, <code>smoke2</code> et <code>smoke3</code> diffèrent. Par exemple, dans ce dernier cas, <code>smoke1</code> est double de la valeur avec les contrastes Helmert, ce qui est logique puisque la référence est ici la droite ajustée pour la sous-population <code>smoke == 0</code> là où dans le modèle avec les contrastes de Helmert, le décalage est mesuré par rapport au modèle moyen (donc à “mi-chemin” entre les deux droites pour <code>smoke == 0</code> et <code>smoke == 1</code>).</p>
<p>Naturellement, nous pouvons aussi considérer la variable <code>smoke</code> réencodée dans <code>Babies2</code> comme une variable facteur ordonné (<code>ordered</code>). Dans ce cas, c’est les contrastes polynomiaux qui sont utilisés :</p>
<pre class="sourceCode r"><code class="sourceCode r">Babies2 <span class="op">%&gt;.%</span>
<span class="st">  </span><span class="kw">mutate</span>(., <span class="dt">smoke =</span> <span class="kw">as.ordered</span>(smoke)) -&gt;
<span class="st">  </span>Babies3
<span class="kw">summary</span>(<span class="kw">lm</span>(<span class="dt">data =</span> Babies3, wt <span class="op">~</span><span class="st"> </span>smoke <span class="op">+</span><span class="st"> </span>wt1))</code></pre>
<pre><code># 
# Call:
# lm(formula = wt ~ smoke + wt1, data = Babies3)
# 
# Residuals:
#      Min       1Q   Median       3Q      Max 
# -1.95453 -0.30780  0.01289  0.31108  1.49443 
# 
# Coefficients:
#              Estimate Std. Error t value Pr(&gt;|t|)    
# (Intercept)  2.985106   0.091695  32.555  &lt; 2e-16 ***
# smoke.L     -0.162480   0.026780  -6.067 1.75e-09 ***
# smoke.Q     -0.148045   0.039294  -3.768 0.000173 ***
# smoke.C     -0.044605   0.048790  -0.914 0.360787    
# wt1          0.007617   0.001534   4.966 7.85e-07 ***
# ---
# Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
# 
# Residual standard error: 0.4999 on 1185 degrees of freedom
# Multiple R-squared:  0.07733, Adjusted R-squared:  0.07422 
# F-statistic: 24.83 on 4 and 1185 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>Notez comment R est capable d’utiliser automatiquement les contrasts adéquats (polynomiaux) lorsque la variable facteur <code>smoke</code> est encodée en <code>ordered</code>. Nous voyons ici que des contrastes tenant compte d’une variation le long des successions croissante de niveaux de “gravité” de la variable <code>smoke</code> sont maintenant calculés. La ligne <code>smoke.L</code> du tableau <code>Coefficients</code> indique une variation linéaire (significative au seuil alpha de 5%), <code>smoke.Q</code> est une variation quadratique (également significative) et enfin <code>smoke.C</code> est une variation cubique. Voyez la présentation des matrices de contrastes plus haut pour bien comprendre ce qui est calculé ici.</p>
<p>Au final, l’élément important relatif à la variable <code>smoke</code> est en définitive le fait de fumer <strong>pendant</strong> la grossesse ou non, pas l’histoire de la mère avant sa grossesse en matière de tabocologie ! En modélisation, nous avons toujours intérêt à choisir le <strong>modèle le plus simple</strong>. Donc ici, cela vaut le coup de simplifier <code>smoke</code> à une variable à deux niveaux <code>smoke_preg</code> qui indique uniquement si la mère fume ou non pendant la grossesse. Ensuite, nous ajustons à nouveau un modèle plus simple avec cette nouvelle variable.</p>
<pre class="sourceCode r"><code class="sourceCode r">Babies <span class="op">%&gt;.%</span>
<span class="st">  </span><span class="kw">mutate</span>(., <span class="dt">smoke_preg =</span> <span class="kw">recode</span>(smoke, <span class="st">&quot;0&quot;</span> =<span class="st"> &quot;0&quot;</span>, <span class="st">&quot;1&quot;</span> =<span class="st"> &quot;1&quot;</span>, <span class="st">&quot;2&quot;</span> =<span class="st"> &quot;0&quot;</span>, <span class="st">&quot;3&quot;</span> =<span class="st"> &quot;0&quot;</span>)) <span class="op">%&gt;.%</span>
<span class="st">  </span><span class="kw">mutate</span>(., <span class="dt">smoke_preg =</span> <span class="kw">factor</span>(smoke_preg, <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;0&quot;</span>, <span class="st">&quot;1&quot;</span>))) -&gt;
<span class="st">  </span>Babies
Babies_lm4 &lt;-<span class="st"> </span><span class="kw">lm</span>(<span class="dt">data =</span> Babies, wt <span class="op">~</span><span class="st"> </span>smoke_preg <span class="op">+</span><span class="st"> </span>wt1)
<span class="kw">summary</span>(Babies_lm4)</code></pre>
<pre><code># 
# Call:
# lm(formula = wt ~ smoke_preg + wt1, data = Babies)
# 
# Residuals:
#      Min       1Q   Median       3Q      Max 
# -1.96243 -0.30708  0.01208  0.31051  1.48662 
# 
# Coefficients:
#              Estimate Std. Error t value Pr(&gt;|t|)    
# (Intercept)  3.037508   0.091896  33.054  &lt; 2e-16 ***
# smoke_preg1 -0.245797   0.029747  -8.263 3.76e-16 ***
# wt1          0.007624   0.001531   4.981 7.25e-07 ***
# ---
# Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
# 
# Residual standard error: 0.4996 on 1187 degrees of freedom
# Multiple R-squared:  0.07692, Adjusted R-squared:  0.07537 
# F-statistic: 49.46 on 2 and 1187 DF,  p-value: &lt; 2.2e-16</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">anova</span>(Babies_lm4)</code></pre>
<pre><code># Analysis of Variance Table
# 
# Response: wt
#              Df  Sum Sq Mean Sq F value    Pr(&gt;F)    
# smoke_preg    1  18.497 18.4971  74.106 &lt; 2.2e-16 ***
# wt1           1   6.193  6.1934  24.813 7.253e-07 ***
# Residuals  1187 296.281  0.2496                      
# ---
# Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1</code></pre>
<p>A présent, tous les termes de notre modèle sont significatifs au seuil alpha de 5%. La ligne <code>smoke_preg1</code> est le décalage de l’ordonnée à l’origine du poids des bébés issus de mères fumant pendant la grossesse. Il donne donc directement la perte moyenne de poids du à la tabacologie. La représentation graphique de ce dernier modèle est la suivante :</p>
<pre class="sourceCode r"><code class="sourceCode r">cols &lt;-<span class="st"> </span>iterators<span class="op">::</span><span class="kw">iter</span>(scales<span class="op">::</span><span class="kw">hue_pal</span>()(<span class="dv">2</span>)) <span class="co"># Get colors for lines</span>
<span class="kw">chart</span>(<span class="dt">data =</span> Babies, wt <span class="op">~</span><span class="st"> </span>wt1) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>(<span class="kw">aes</span>(<span class="dt">col =</span> smoke_preg)) <span class="op">+</span>
<span class="st">  </span><span class="kw">lapply</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="fl">-0.246</span>), <span class="cf">function</span>(offset)
    <span class="kw">geom_smooth</span>(<span class="dt">method =</span> lm, <span class="dt">formula =</span> y <span class="op">+</span><span class="st"> </span>offset <span class="op">~</span><span class="st"> </span>x,
      <span class="dt">col =</span> iterators<span class="op">::</span><span class="kw">nextElem</span>(cols))) <span class="op">+</span>
<span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;Masse de la mère [kg]&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;Masse du bébé [kg]&quot;</span>)</code></pre>
<p><img src="03-mod-lineaire_files/figure-html/unnamed-chunk-30-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Enfin, n’oublions pas que notre modèle n’est valide que si les conditions d’application sont rencontrées, en particulier, une distribution normale des résidus et une homoscédasticité (même variance pour les résidus). Nous vérifions cela visuellement toujours avec les graphiques d’analyse des résidus. En voici les plus importants (pensez à utiliser les snippets pour récupérer le template du code) :</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co">#plot(Babies_lm4, which = 1)</span>
Babies_lm4 <span class="op">%&gt;.%</span>
<span class="st">  </span><span class="kw">chart</span>(broom<span class="op">::</span><span class="kw">augment</span>(.), .resid <span class="op">~</span><span class="st"> </span>.fitted) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_hline</span>(<span class="dt">yintercept =</span> <span class="dv">0</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">se =</span> <span class="ot">FALSE</span>, <span class="dt">method =</span> <span class="st">&quot;loess&quot;</span>, <span class="dt">formula =</span> y <span class="op">~</span><span class="st"> </span>x) <span class="op">+</span>
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">&quot;Fitted values&quot;</span>, <span class="dt">y =</span> <span class="st">&quot;Residuals&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Residuals vs Fitted&quot;</span>)</code></pre>
<p><img src="03-mod-lineaire_files/figure-html/unnamed-chunk-31-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co">#plot(Babies_lm4, which = 2)</span>
Babies_lm4 <span class="op">%&gt;.%</span>
<span class="st">  </span><span class="kw">chart</span>(broom<span class="op">::</span><span class="kw">augment</span>(.), <span class="kw">aes</span>(<span class="dt">sample =</span> .std.resid)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_qq</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_qq_line</span>(<span class="dt">colour =</span> <span class="st">&quot;darkgray&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">&quot;Theoretical quantiles&quot;</span>, <span class="dt">y =</span> <span class="st">&quot;Standardized residuals&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Normal Q-Q&quot;</span>)</code></pre>
<p><img src="03-mod-lineaire_files/figure-html/unnamed-chunk-32-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co">#plot(Babies_lm4, which = 3)</span>
Babies_lm4 <span class="op">%&gt;.%</span>
<span class="st">  </span><span class="kw">chart</span>(broom<span class="op">::</span><span class="kw">augment</span>(.), <span class="kw">sqrt</span>(<span class="kw">abs</span>(.std.resid)) <span class="op">~</span><span class="st"> </span>.fitted) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">se =</span> <span class="ot">FALSE</span>, <span class="dt">method =</span> <span class="st">&quot;loess&quot;</span>, <span class="dt">formula =</span> y <span class="op">~</span><span class="st"> </span>x) <span class="op">+</span>
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">&quot;Fitted values&quot;</span>,
    <span class="dt">y =</span> <span class="kw">expression</span>(<span class="kw">bold</span>(<span class="kw">sqrt</span>(<span class="kw">abs</span>(<span class="st">&quot;Standardized residuals&quot;</span>))))) <span class="op">+</span>
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Scale-Location&quot;</span>)</code></pre>
<p><img src="03-mod-lineaire_files/figure-html/unnamed-chunk-33-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co">#plot(Babies_lm4, which = 4)</span>
Babies_lm4 <span class="op">%&gt;.%</span>
<span class="st">  </span><span class="kw">chart</span>(broom<span class="op">::</span><span class="kw">augment</span>(.), .cooksd <span class="op">~</span><span class="st"> </span><span class="kw">seq_along</span>(.cooksd)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_bar</span>(<span class="dt">stat =</span> <span class="st">&quot;identity&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_hline</span>(<span class="dt">yintercept =</span> <span class="kw">seq</span>(<span class="dv">0</span>, <span class="fl">0.1</span>, <span class="dt">by =</span> <span class="fl">0.05</span>), <span class="dt">colour =</span> <span class="st">&quot;darkgray&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">x =</span> <span class="st">&quot;Obs. number&quot;</span>, <span class="dt">y =</span> <span class="st">&quot;Cook&#39;s distance&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Cook&#39;s distance&quot;</span>)</code></pre>
<p><img src="03-mod-lineaire_files/figure-html/unnamed-chunk-34-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Ici le comportement des résidus est sain. Des petits écarts de la normalité sur le graphique quantile-quantile s’observent peut-être, mais ce n’est pas dramatique et le modèle linéaire est rabuste à ce genre de petis changements d’autant plus qu’ils apparaissent relativement symétriques en haut et et en bas de la distribution. En conclusion de cette analyse, nous pouvons dire que la masse du bébé dépend de la masse de la mère, mais assez faiblement (seulement 7,7% de la variance totale expliquée). Par contre, nous pouvons aussi dire que le fait de fumer pendant la grossesse a un effet significatif sur la réduction de la masse du bébé à la naissance (en moyenne cette réduction est de 0,246kg pour une masse moyenne à la naissance de 3,038kg, soit une réduction de 0,246 / 3,034 * 100 = 8%).</p>
<p>Voilà, nous venons d’analyser et d’interpréter notre premier modèle linéaire sous forme d’une ANCOVA.</p>
<h5 id="a-vous-de-jouer-5" class="unnumbered">A vous de jouer !</h5>
<p>Après cette longue lecture avec énormément de nouvelles matières, nous vous proposons les exercices suivants :</p>
<ul>
<li>Répondez aux questions d’un learnr afin de vérifier vos acquis.</li>
</ul>

<div class="bdd">
<p>Démarrez la SciViews Box et RStudio. Dans la fenêtre <strong>Console</strong> de RStudio, entrez l’instruction suivante suivie de la touche <code>Entrée</code> pour ouvrir le tutoriel concernant les bases de R :</p>
<pre><code>BioDataScience2::run(&quot;03a_mod_lin&quot;)</code></pre>
N’oubliez pas d’appuyer sur la touche <code>ESC</code> pour reprendre la main dans R à la fin d’un tutoriel dans la console R.
</div>
<ul>
<li>Poursuivez l’analyse des données sur la biométrie des oursins en y intégrant vos nouvelles notions sur le modèle linéaire</li>
</ul>

<div class="bdd">
<p>Reprenez votre travail sur la biométrie des oursins et appliquer les nouvelles notions vues</p>
</div>
<h2 id="modele-lineaire-generalise">Modèle linéaire généralisé</h2>
<p>Le modèle linéaire nous a permis de combiner différent types de <strong>variables indépendantes ou explicatives </strong> dans un même modèle. Cependant la <strong>variable dépendante ou réponse</strong> à la gauche de l’équation doit <em>absolument</em> être numérique et une distribution normale est exigée pour la composante statistique du modèle exprimée dans les résidus <span class="math inline">\(\epsilon\)</span>. Donc, si nous voulons modéliser une variable dépendante qui ne répond pas à ces caractéristiques, nous sommes dans l’impasse avec la fonction <code>lm()</code>. Dans certains cas, une transformation des données peut résoudre le problème. Par exemple, prendre le logarithme d’une variable qui a une distribution log-normale. Dans d’autres cas, il semble qu’il n’y ait pas de solution… C’est ici que la <strong>modèle linéaire <em>généralisé</em></strong> vient nous sauver la mise.</p>
<p>Le modèle linéaire généralisé se représente comme suit :</p>
<p><span class="math display">\[
f(y) = \beta_1 + \beta_2 I_2 + \beta_3 I_3 + ... + \beta_k I_k + \beta_l x_1 + \beta_m x_2 + ... + \epsilon
\]</span></p>
<p>La différence par rapport au modèle linéaire, c’est que notre variable dépendante <span class="math inline">\(y\)</span> est <strong>transformée</strong> à l’aide d’une fonction <span class="math inline">\(f(y)\)</span> que l’on appelle <strong>fonction de lien</strong>. Cette fonction de lien est choisie soigneusement pour transformer une variable qui a une distribution non-normale vers une distribution normale ou quasi-normale. Du coup, il ne faut rien changer à la droite du signe égal par rapport au modèle linéaire, et les outils existants peuvent être réemployés.</p>
<p>Toute la difficulté ici tient donc à la définition des fonctions de liens pertinentes par rapport à la distribution de <span class="math inline">\(y\)</span>. Le tableau suivant reprend les principales situations prises en compte par la fonction <code>glm()</code> dans R qui calcule le modèle linéaire généralisé.</p>
<table>
<colgroup>
<col width="27%" />
<col width="32%" />
<col width="40%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Distribution de Y</th>
<th align="left">Fonction de lien</th>
<th align="left">Code R</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Gaussienne (Normale)</td>
<td align="left">identité (pas de transfo.)</td>
<td align="left"><code>glm(..., family = gaussian(link = &quot;identity&quot;))</code></td>
</tr>
<tr class="even">
<td align="left">Log-Normale</td>
<td align="left">log</td>
<td align="left"><code>glm(..., family = gaussian(link = &quot;log&quot;))</code></td>
</tr>
<tr class="odd">
<td align="left">Binomiale</td>
<td align="left">logit</td>
<td align="left"><code>glm(..., family = binomial(link = logit))</code></td>
</tr>
<tr class="even">
<td align="left">Binomiale</td>
<td align="left">probit (alternative)</td>
<td align="left"><code>glm(..., family = binomial(link = probit))</code></td>
</tr>
<tr class="odd">
<td align="left">Poisson</td>
<td align="left">log</td>
<td align="left"><code>glm(..., family = poisson(link = log))</code></td>
</tr>
</tbody>
</table>
<p>Il en existe bien d’autres. Voyez l’aide de <code>?family</code> pour plus de détails. Par exemple, pour une variable réponse binaire acceptant seulement deux valeurs possibles et ayant une distribution binomiale, avec une réponse de type logistique (une variation croissante d’une ou plusieurs variables indépendantes fait passer la proportion des individus appartenant au second état selon une courbe logistique en S), une fonction de type <strong>logit</strong> est à utiliser.</p>
<p><span class="math display">\[
y = 1/(1 + e^{- \beta x})
\]</span></p>
<p>La transformation <strong>logit</strong> calcule alors : <span class="math inline">\(\ln(y / (1 - y)) = \beta x\)</span>. Les situations correspondant à ce cas de figure concernent par exemple des variables de type (vivant <em>versus</em> mort) par rapport à une situation potentiellement léthale, ou alors, le développement d’une maladie lors d’une épidémie (sain <em>versus</em> malade).</p>
<h3 id="exemple">Exemple</h3>
<p>Continuons à analyser nos données concernant les bébés à la naissance. Un bébé prématuré est un bébé qui nait avant 37 semaines de grossesse. Dans notre jeu de données <code>Babies</code>, nous pouvons déterminer si un enfant est prématuré ou non (variable binaire) à partir de la variable <code>gestation</code>(en jours). Transformons nos données pour obtenir les variables d’intérêt.</p>
<pre class="sourceCode r"><code class="sourceCode r">SciViews<span class="op">::</span>R
babies &lt;-<span class="st"> </span><span class="kw">read</span>(<span class="st">&quot;babies&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;UsingR&quot;</span>)
babies <span class="op">%&gt;.%</span><span class="st"> </span><span class="kw">select</span>(., gestation, smoke, wt1, ht, race, age) <span class="op">%&gt;.%</span>
<span class="st">  </span><span class="co"># Eliminer les valeurs manquantes</span>
<span class="st">  </span><span class="kw">filter</span>(., gestation <span class="op">&lt;</span><span class="st"> </span><span class="dv">999</span>, smoke <span class="op">&lt;</span><span class="st"> </span><span class="dv">9</span>, wt1 <span class="op">&lt;</span><span class="st"> </span><span class="dv">999</span>, ht <span class="op">&lt;</span><span class="st"> </span><span class="dv">999</span>, race <span class="op">&lt;</span><span class="st"> </span><span class="dv">99</span>, age <span class="op">&lt;</span><span class="st"> </span><span class="dv">99</span>) <span class="op">%&gt;.%</span>
<span class="st">  </span><span class="co"># Transformer wt1 en kg et ht en cm</span>
<span class="st">  </span><span class="kw">mutate</span>(., <span class="dt">wt1 =</span> wt1 <span class="op">*</span><span class="st"> </span><span class="fl">0.4536</span>) <span class="op">%&gt;.%</span>
<span class="st">  </span><span class="kw">mutate</span>(., <span class="dt">ht =</span> ht <span class="op">/</span><span class="st"> </span><span class="fl">39.37</span>) <span class="op">%&gt;.%</span>
<span class="st">  </span><span class="co"># Transformer smoke en variable facteur</span>
<span class="st">  </span><span class="kw">mutate</span>(., <span class="dt">smoke =</span> <span class="kw">as.factor</span>(smoke)) <span class="op">%&gt;.%</span>
<span class="st">  </span><span class="co"># Idem pour race</span>
<span class="st">  </span><span class="kw">mutate</span>(., <span class="dt">race =</span> <span class="kw">as.factor</span>(race)) <span class="op">%&gt;.%</span>
<span class="st">  </span><span class="co"># Déterminer si un bébé est prématuré ou non (en variable facteur)</span>
<span class="st">  </span><span class="kw">mutate</span>(., <span class="dt">premat =</span> <span class="kw">as.factor</span>(<span class="kw">as.numeric</span>(gestation <span class="op">&lt;</span><span class="st"> </span><span class="dv">7</span><span class="op">*</span><span class="dv">37</span>))) <span class="op">%&gt;.%</span>
<span class="st">  </span><span class="co"># Calculer le BMI comme meilleur index d&#39;embonpoint des mères que leur masse</span>
<span class="st">  </span><span class="kw">mutate</span>(., <span class="dt">bmi =</span> wt1 <span class="op">/</span><span class="st"> </span>ht<span class="op">^</span><span class="dv">2</span>) -&gt;
<span class="st">  </span>Babies_prem</code></pre>
<p>Comment se répartissent les enfants entre prématurés et nés à terme ?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">table</span>(Babies_prem<span class="op">$</span>premat)</code></pre>
<pre><code># 
#    0    1 
# 1080   96</code></pre>
<p>Nous avons un nombre relativement faible de prématurés dans l’ensemble. C’était à prévoir. Attention à un plan très mal balancé ici : c’est défavorable à une bonne analyse, mais pas rédhibitoire. Décrivons ces données.</p>
<pre class="sourceCode r"><code class="sourceCode r">Babies_table &lt;-<span class="st"> </span><span class="kw">table</span>(Babies_prem<span class="op">$</span>premat, Babies_prem<span class="op">$</span>smoke)
knitr<span class="op">::</span><span class="kw">kable</span>(<span class="kw">addmargins</span>(Babies_table))</code></pre>
<table>
<thead>
<tr class="header">
<th></th>
<th align="right">0</th>
<th align="right">1</th>
<th align="right">2</th>
<th align="right">3</th>
<th align="right">Sum</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td align="right">486</td>
<td align="right">420</td>
<td align="right">83</td>
<td align="right">91</td>
<td align="right">1080</td>
</tr>
<tr class="even">
<td>1</td>
<td align="right">39</td>
<td align="right">40</td>
<td align="right">9</td>
<td align="right">8</td>
<td align="right">96</td>
</tr>
<tr class="odd">
<td>Sum</td>
<td align="right">525</td>
<td align="right">460</td>
<td align="right">92</td>
<td align="right">99</td>
<td align="right">1176</td>
</tr>
</tbody>
</table>
<p>Ce tableau de contingence ne nous donne pas encore l’idée de la répartition de prématurés en fonction de statut de fumeuse de la mère, mais le graphique suivant nous le montre.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">chart</span>(<span class="dt">data =</span> Babies_prem, <span class="op">~</span>smoke <span class="op">%fill=%</span><span class="st"> </span>premat) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_bar</span>(<span class="dt">position =</span> <span class="st">&quot;fill&quot;</span>)</code></pre>
<p><img src="03-mod-lineaire_files/figure-html/unnamed-chunk-40-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Il ne semble pas y avoir un effet flagrant, même si le niveau <code>smoke == 2</code> semble contenir une plus forte proportion de prématurés. Qu’en est-il en fonction de l’éthnicité (voir <code>help(babies, packahge = &quot;UsingR&quot;)</code> pour le détail sur les variétés éthniques considérées) de la mère (variable <code>race</code>) ?</p>
<pre class="sourceCode r"><code class="sourceCode r">Babies_table &lt;-<span class="st"> </span><span class="kw">table</span>(Babies_prem<span class="op">$</span>premat, Babies_prem<span class="op">$</span>race)
knitr<span class="op">::</span><span class="kw">kable</span>(<span class="kw">addmargins</span>(Babies_table))</code></pre>
<table>
<thead>
<tr class="header">
<th></th>
<th align="right">0</th>
<th align="right">1</th>
<th align="right">2</th>
<th align="right">3</th>
<th align="right">4</th>
<th align="right">5</th>
<th align="right">6</th>
<th align="right">7</th>
<th align="right">8</th>
<th align="right">9</th>
<th align="right">10</th>
<th align="right">Sum</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td align="right">491</td>
<td align="right">42</td>
<td align="right">22</td>
<td align="right">58</td>
<td align="right">50</td>
<td align="right">124</td>
<td align="right">31</td>
<td align="right">192</td>
<td align="right">34</td>
<td align="right">24</td>
<td align="right">12</td>
<td align="right">1080</td>
</tr>
<tr class="even">
<td>1</td>
<td align="right">24</td>
<td align="right">2</td>
<td align="right">5</td>
<td align="right">1</td>
<td align="right">6</td>
<td align="right">8</td>
<td align="right">3</td>
<td align="right">41</td>
<td align="right">5</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">96</td>
</tr>
<tr class="odd">
<td>Sum</td>
<td align="right">515</td>
<td align="right">44</td>
<td align="right">27</td>
<td align="right">59</td>
<td align="right">56</td>
<td align="right">132</td>
<td align="right">34</td>
<td align="right">233</td>
<td align="right">39</td>
<td align="right">25</td>
<td align="right">12</td>
<td align="right">1176</td>
</tr>
</tbody>
</table>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">chart</span>(<span class="dt">data =</span> Babies_prem, <span class="op">~</span>race <span class="op">%fill=%</span><span class="st"> </span>premat) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_bar</span>(<span class="dt">position =</span> <span class="st">&quot;fill&quot;</span>)</code></pre>
<p><img src="03-mod-lineaire_files/figure-html/unnamed-chunk-42-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Ici, nous voyons déjà un effet semble-t-il plus marqué. Qu’en est-il du BMI ?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">chart</span>(<span class="dt">data =</span> Babies_prem, bmi <span class="op">~</span><span class="st"> </span>premat) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_boxplot</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;BMI de la mère&quot;</span>)</code></pre>
<p><img src="03-mod-lineaire_files/figure-html/unnamed-chunk-43-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Sur ce graphique, il ne semble pas y avoir d’influence du BMI sur le fait d’avoir un enfant prématuré ou non. Enfin, l’âge de la mère influence-t-il également ?</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">chart</span>(<span class="dt">data =</span> Babies_prem, age <span class="op">~</span><span class="st"> </span>premat) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_boxplot</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;Age de la mère (an)&quot;</span>)</code></pre>
<p><img src="03-mod-lineaire_files/figure-html/unnamed-chunk-44-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Il ne sembnle pas y avoir un effet flagrant. Voyons ce que donne le modèle (nous ne considérons pas les interactions possibles ici, mais cela doit être fait dans le cas de plusieurs effets significatifs au moins). Avec 4 variables explicatives, le modèle est déjà très complexe sans interactions. Nous serions trop ambitieux de vouloir ici ajuster un modèle complet !</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Modèle linéaire généralisé avec fonction de lien de type logit</span>
Babies_glm &lt;-<span class="st"> </span><span class="kw">glm</span>(<span class="dt">data =</span> Babies_prem, premat <span class="op">~</span><span class="st"> </span>smoke <span class="op">+</span><span class="st"> </span>race <span class="op">+</span><span class="st"> </span>bmi <span class="op">+</span><span class="st"> </span>age,
  <span class="dt">family =</span> <span class="kw">binomial</span>(<span class="dt">link =</span> logit))
<span class="kw">summary</span>(Babies_glm)</code></pre>
<pre><code># 
# Call:
# glm(formula = premat ~ smoke + race + bmi + age, family = binomial(link = logit), 
#     data = Babies_prem)
# 
# Deviance Residuals: 
#     Min       1Q   Median       3Q      Max  
# -0.6875  -0.4559  -0.3228  -0.2857   2.8199  
# 
# Coefficients:
#               Estimate Std. Error z value Pr(&gt;|z|)    
# (Intercept)  -3.349082   0.860945  -3.890  0.00010 ***
# smoke1        0.247161   0.244442   1.011  0.31196    
# smoke2        0.247474   0.401007   0.617  0.53715    
# smoke3        0.245883   0.417970   0.588  0.55634    
# race1        -0.037501   0.754621  -0.050  0.96037    
# race2         1.510254   0.539895   2.797  0.00515 ** 
# race3        -1.017780   1.030541  -0.988  0.32334    
# race4         0.891191   0.481411   1.851  0.06414 .  
# race5         0.303990   0.421363   0.721  0.47064    
# race6         0.750868   0.644376   1.165  0.24391    
# race7         1.495166   0.280313   5.334 9.61e-08 ***
# race8         1.155898   0.531592   2.174  0.02967 *  
# race9        -0.123997   1.043118  -0.119  0.90538    
# race10      -13.513140 691.812473  -0.020  0.98442    
# bmi          -0.001689   0.032621  -0.052  0.95871    
# age           0.007806   0.019119   0.408  0.68307    
# ---
# Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
# 
# (Dispersion parameter for binomial family taken to be 1)
# 
#     Null deviance: 665.00  on 1175  degrees of freedom
# Residual deviance: 618.84  on 1160  degrees of freedom
# AIC: 650.84
# 
# Number of Fisher Scoring iterations: 15</code></pre>
<p>Nous voyons que le résumé de l’objet <code>glm</code> est très similaire à celui d’un objet <code>lm</code>, notamment avec un tableau des <code>Coefficients</code> identique et qui s’interprète de la même manière. Ici, nous pouvons confirmer que ni le fait de fumer, ni l’âge, ni le BMI de la mère n’a d’incidence sur les bébés prématurés au seuil alpha de 5%. En revanche, certaines éthnies sont significativement plus susceptibles d’accoucher avant terme. Cela suggère soit un facteur génétique, soit un facteur environnmental/culturel lié à ces éthnies. Naturellement, il faudrait ici simplifier le modèle qui se ramène en fin de compte à l’équivalent d’une ANOVA à un facteur, mais en version <code>glm()</code> une fois que les variables non significatives sont éliminées. De même, on pourrait légitimement se demander si la variable <code>premat</code> ne pourrait pas aussi être modélisée avec une autre fonction de lien en considérant une distribution de Poisson par exemple. A vous de voir…</p>
<h5 id="a-vous-de-jouer-6" class="unnumbered">A vous de jouer !</h5>
<ul>
<li>Réalisez un rapport scientifique sur la maturation d’ovocytes, en définissant un modèle linéaire généralisé le plus pertinent pour ces données.</li>
</ul>

<div class="bdd">
<p>Vous avez à votre disposition une assignation GitHub Classroom :</p>
<ul>
<li><a href="https://classroom.github.com/a/mXAIu4Ir" class="uri">https://classroom.github.com/a/mXAIu4Ir</a></li>
</ul>
<p>Lisez le README afin de prendre connaissance de l’exercice</p>
</div>
<ul>
<li>Réalisez un rapport scientifique sur la biométrie humaine.

<div class="bdd">
<p>Vous avez à votre disposition une assignation GitHub Classroom :</p></li>
<li><p><a href="https://classroom.github.com/a/hS069etL" class="uri">https://classroom.github.com/a/hS069etL</a></p></li>
</ul>
<p>Lisez le README afin de prendre connaissance de l’exercice</p>
</div>


</div>
</div>
<!-- </div> -->
<h3>Références</h3>
<div id="refs" class="references">
<div id="ref-verzani2005">
<p>Verzani, John. 2005. <em>Using R for Introductory Statistics</em>. Boca Raton, Florida: Chapman; Hall/CRC. <a href="https://www.crcpress.com/Using-R-for-Introductory-Statistics/Verzani/p/book/9781466590731">https://www.crcpress.com/Using-R-for-Introductory-Statistics/Verzani/p/book/9781466590731</a>.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="5">
<li id="fn5"><p>Concrètement, un cas aussi simple se traite habituellement à l’aide d’un test <em>t</em> de Student, mais pour notre démonstration, nous allons considérer ici utiliser une ANOVA à un facteur plutôt.<a href="rmse-critere-dakaike.html#fnref5" class="footnote-back">↩</a></p></li>
<li id="fn6"><p>Attention : le fait d’utiliser une matrtice de contraste qui restreint ceux utilisés dans le modèle est indépendant des tests <em>post hoc</em> de comparaisons multiples, qui restent utilisables par après. Les comparaisons deux à deux des médicaments restent donc accessibles, mais ils ne sont tout simplement pas mis en évidence dans le modèle de base.<a href="rmse-critere-dakaike.html#fnref6" class="footnote-back">↩</a></p></li>
<li id="fn7"><p>Pour rappel, on utilise le signe <code>+</code> pour indiquer un modèle sans interactions et un signe <code>*</code>pour spécifier un modèle complet avec interactions entre les variables.<a href="rmse-critere-dakaike.html#fnref7" class="footnote-back">↩</a></p></li>
</ol>
</div>
<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://sddb.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
            </section>

          </div>
        </div>
      </div>
<a href="regression-lineaire-polynomiale.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="reg-non-lin.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/BioDataScience-Course/sdd-umons2/edit/master/02-reg-lineaire-2.Rmd",
"text": "Editer"
},
"history": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
